<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Study Notes</title>
    <link href="http://vivek.im/notes/feed.xml" rel="self" />
    <link href="http://vivek.im/notes/" />
    <updated>2013-05-03T19:01:15+05:30</updated>
    <id>http://vivek.im/notes/</id>
    <entry>
        <title type="html"><![CDATA[S2 - Integer and Floating Point Numbers]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s2.html"/>
        <published>2013-05-01T00:00:00+05:30</published>
        <updated>2013-05-02T01:48:00+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s2.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <div class="section" id="unsigned-integers">
<h2>Unsigned Integers</h2>
<p>Possible number of values for N bits = 2<sup>N</sup> - 1</p>
<p>Addition/Subtraction can be done with the normal &quot;carry/borrow&quot; rules.</p>
</div>
<div class="section" id="signed-integers">
<h2>Signed Integers</h2>
<p>For unsigned integers example:</p>
<p>8 bits: <tt class="docutils literal">0x00=0</tt>, <tt class="docutils literal">0x01=1</tt>, ..., <tt class="docutils literal">0x7F=127</tt></p>
<p>But we need half of them to be negative.</p>
<p>The high order bit is used to indicate negative. This is called &quot;sign-and-magnitude&quot; representation.</p>
<p>Example:</p>
<ul class="simple">
<li><tt class="docutils literal">0x00</tt> = 00000000<sub>2</sub> is non-negative, because the sign bit is 0</li>
<li><tt class="docutils literal">0x7F</tt> = 01111111<sub>2</sub> is non-negative</li>
<li><tt class="docutils literal">0x85</tt> = 10000101<sub>2</sub> is negative</li>
<li><tt class="docutils literal">0x80</tt> = 10000000<sub>2</sub> is negative</li>
</ul>
<p>But there are two values for <tt class="docutils literal">0</tt><sub>10</sub> : <tt class="docutils literal">0x00</tt> (+0) and <tt class="docutils literal">0x80</tt> (-0).</p>
<p>This can create problems for example:</p>
<p>4 - 3 = <tt class="docutils literal">0100</tt><sub>2</sub> - <tt class="docutils literal">0011</tt><sub>2</sub> = <tt class="docutils literal">0001</tt><sub>2</sub> = 1</p>
<p>4 + (-3) = <tt class="docutils literal">0100</tt><sub>2</sub> + <tt class="docutils literal">1011</tt><sub>2</sub> = <tt class="docutils literal">1111</tt><sub>2</sub> = -7</p>
<p>Therefore, 4 - 3 != 4 + (-3)</p>
<p>We do not want this! Instead what is used is two's complement negatives.</p>
</div>
<div class="section" id="two-s-complement-negatives">
<h2>Two's Complement Negatives</h2>
<p>Rather than having a sign bit as in Signed integers, let the most significant bit have the same value but negative weight.</p>
<p>Example:</p>
<ul class="simple">
<li>unsigned 1010<sub>2</sub> : 1*2<sup>3</sup> + 0*2<sup>2</sup> + 1*2<sup>1</sup> + 0*2<sup>0</sup> = 10<sub>10</sub></li>
<li>2's comp 1010<sub>2</sub> : -1*2<sup>3</sup> + 0*2<sup>2</sup> + 1*2<sup>1</sup> + 0*2<sup>0</sup> = -6<sub>10</sub></li>
</ul>
<p>-1 is represented as <tt class="docutils literal">1111</tt><sub>2</sub>, all negative integers still have MSB = 1. Also, there is only one zero.</p>
<p>To get the negative representation of any integer, take bitwise compliment and then add one!</p>
<p><tt class="docutils literal">~x + 1 = <span class="pre">-x</span></tt></p>
<p>Arithmetic example:</p>
<ul class="simple">
<li>4 + 3 = <tt class="docutils literal">0100</tt> + <tt class="docutils literal">0011</tt> = <tt class="docutils literal">0111</tt> = 7</li>
<li>-4 + 3 = <tt class="docutils literal">1100</tt> + <tt class="docutils literal">0011</tt> = <tt class="docutils literal">1111</tt> = -1</li>
<li>4 - 3 = <tt class="docutils literal">0100</tt> + <tt class="docutils literal">1101</tt> = <tt class="docutils literal">10001</tt> = <tt class="docutils literal">0001</tt> = 1</li>
</ul>
<p>Here in the last example, the highest carry bit is dropped. This is called modular addition.</p>
</div>
<div class="section" id="signed-and-unsigned-numeric-values">
<h2>Signed and Unsigned Numeric Values</h2>
<p>Both signed and unsigned integers have limits. For 4 bit values:</p>
<ul class="simple">
<li>If you compute a number that is too big like 6 + 4 = ? or 15U + 2U = ?</li>
<li>If you compute a numbet that is too small like -7 -3 = ? or 0U - 2U = ?</li>
</ul>
<p>The CPU may be capable of &quot;throwing an exception&quot; for overflow on signed values but it won't for unsigned. C &amp; Java don't give a fuck when this happens and silently cruise along. We need to be careful about this and explicitly check.</p>
</div>
<div class="section" id="values-to-remember">
<h2>Values to remember</h2>
<p>Unsigned Values:</p>
<ul class="simple">
<li>UMin = 0 (<tt class="docutils literal"><span class="pre">000...0</span></tt>)</li>
<li>UMax = 2<sup>w</sup> - 1 (<tt class="docutils literal"><span class="pre">111...1</span></tt>)</li>
</ul>
<p>Two's Complement Values:</p>
<ul class="simple">
<li>TMin = -2<sup>w-1</sup> (<tt class="docutils literal"><span class="pre">100...0</span></tt>)</li>
<li>TMax = 2<sup>w-1</sup> - 1 (<tt class="docutils literal"><span class="pre">011..1</span></tt>)</li>
<li>Negative 1 = <tt class="docutils literal"><span class="pre">111...1</span></tt> or 0xFFFFFFFF (32-bits)</li>
</ul>
<p>Values for W = 16 (16-bit systems)</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="21%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">&nbsp;</th>
<th class="head" rowspan="2">Decimal</th>
<th class="head" rowspan="2">Hex</th>
<th class="head" rowspan="2">Binary</th>
</tr>
<tr></tr>
</thead>
<tbody valign="top">
<tr><td>UMax</td>
<td>65535</td>
<td><tt class="docutils literal">FF FF</tt></td>
<td><tt class="docutils literal">11111111 11111111</tt></td>
</tr>
<tr><td>TMax</td>
<td>32767</td>
<td><tt class="docutils literal">7F FF</tt></td>
<td><tt class="docutils literal">01111111 11111111</tt></td>
</tr>
<tr><td>TMin</td>
<td>-32768</td>
<td><tt class="docutils literal">80 00</tt></td>
<td><tt class="docutils literal">10000000 00000000</tt></td>
</tr>
<tr><td>-1</td>
<td>-1</td>
<td><tt class="docutils literal">FF FF</tt></td>
<td><tt class="docutils literal">11111111 11111111</tt></td>
</tr>
<tr><td>0</td>
<td>0</td>
<td><tt class="docutils literal">00 00</tt></td>
<td><tt class="docutils literal">00000000 00000000</tt></td>
</tr>
</tbody>
</table>
<p>Some observations:</p>
<ul>
<li><div class="first line-block">
<div class="line">TMin | = TMax + 1</div>
</div>
</li>
<li><p class="first">UMax = 2 * TMax + 1</p>
</li>
</ul>
</div>
<div class="section" id="integers-in-c">
<h2>Integers in C</h2>
<p>C has support for unsigned and signed numbers with <tt class="docutils literal">#include&lt;limits.h&gt;</tt>. In this header file, there are some contants pre-declared for us such as:</p>
<ul class="simple">
<li>ULONG_MAX</li>
<li>LONG_MAX</li>
<li>LONG_MIN</li>
</ul>
<p>These values are platform specific.</p>
<p><strong>Constants</strong></p>
<ul class="simple">
<li>By default, constants are considered signed integers</li>
<li>Use &quot;U&quot; suffix to force unsigned, e.g. <tt class="docutils literal">0U</tt>, <tt class="docutils literal">4294967259U</tt></li>
</ul>
<p><strong>Casting</strong></p>
<ul class="simple">
<li><tt class="docutils literal">int tx, ty;</tt> - signed integer</li>
<li><tt class="docutils literal">unsigned ux, uy;</tt> - unsigned integer</li>
<li><tt class="docutils literal">tx = (int) ux;</tt> - unsigned casted as signed integer</li>
<li><tt class="docutils literal">uy = (unsigned) ty;</tt> - signed casted as unsigned integer</li>
<li><tt class="docutils literal">tx = ux</tt> - implicit casting also occurs via assignments and function calls</li>
<li><tt class="docutils literal">uy = ty</tt> - same as above</li>
<li>The <tt class="docutils literal">gcc</tt> flag <tt class="docutils literal"><span class="pre">-Wsign-convention</span></tt> produces warning for implicit casts, but <tt class="docutils literal"><span class="pre">-Wall</span></tt> doesn't.</li>
</ul>
<p>Here, the bits are unchanged, they are just interpreted differently.</p>
<p>Some casting surprises:</p>
<ul class="simple">
<li>If signed and unsigned are mixed in a single expression, then signed values are implicitly casted to unsigned.</li>
<li>Including comparision operators &lt;, &gt;, ==, &lt;=, &gt;=</li>
</ul>
</div>
<div class="section" id="shift-operations-for-unsigned-integers">
<h2>Shift operations for Unsigned Integers</h2>
<p>Left Shift: x&lt;&lt;y</p>
<ul class="simple">
<li>Shift bit-vector x left by y positions.</li>
<li>Throw away extra bits on the left and fill with <tt class="docutils literal">0s</tt> on the right.</li>
</ul>
<p>Right Shift: x&gt;&gt;y</p>
<ul class="simple">
<li>Shift bit-vector x right by y positions.</li>
<li>Throw away extra bits on the right and fill with <tt class="docutils literal">0s</tt> on the left.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">00000110</tt> (6)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">00110000</tt> (48)</td>
</tr>
<tr><td>&gt;&gt; 2</td>
<td><tt class="docutils literal">00000001</tt> (1)</td>
</tr>
</tbody>
</table>
<p>Here, when we left-shifted binary of 6 by 3 positions, we multiplied 6 by 2<sup>3</sup> which yielded 48.</p>
<p>When we right-shifted binary of 6 by 2 positions, we divided it by 2<sup>2</sup> which should have yielded 1.5 but since we can't represent fraction, so the result was 1.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">11110010</tt> (242)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">10010000</tt> (144 - wrong)</td>
</tr>
<tr><td>&gt;&gt; 2</td>
<td><tt class="docutils literal">00111100</tt> (60)</td>
</tr>
</tbody>
</table>
<p>Here, when binary of 242 was left-shifted by 3 positions, the result should have been 242 * 2<sup>3</sup> = 1936 but instead we got 144 since 1936 doesn't fits in 8 bit and additional bits on the left were dropped.</p>
<p>When binary of 242 was right-shifted by 2 positions, we got the correct result of 242 / 2<sup>2</sup>  = 60.5 (rounded down to 60).</p>
</div>
<div class="section" id="shift-operations-for-signed-integers">
<h2>Shift operations for signed integers</h2>
<p>Left Shift: x&lt;&lt;y</p>
<ul class="simple">
<li>Equivalent to multiplying x by 2<sup>y</sup> </li>
<li>(if resulting value fits, no 1s are lost)</li>
</ul>
<p>Right Shift: x&gt;&gt;y</p>
<ul class="simple">
<li>Logical Shift (for unsigned values) - fill with 0s on the left</li>
<li>Arithmetic Shift (for signed values) - replicate MSB on left and maintains sign of x</li>
<li>Equivalent to dividing x by 2<sup>y</sup> </li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">01100010</tt> (98)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">00010000</tt> (16 - wrong)</td>
</tr>
<tr><td>Logical &gt;&gt; 2</td>
<td><tt class="docutils literal">00011000</tt> (24)</td>
</tr>
<tr><td>Arithmetic &gt;&gt; 2</td>
<td><tt class="docutils literal">00011000</tt> (24)</td>
</tr>
</tbody>
</table>
<p>Now with a negative integer.</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">10100010</tt> (-94)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">00010000</tt> (16 - wrong)</td>
</tr>
<tr><td>Logical &gt;&gt; 2</td>
<td><tt class="docutils literal">00101000</tt> (40 - wrong)</td>
</tr>
<tr><td>Arithmetic &gt;&gt; 2</td>
<td><tt class="docutils literal">11101000</tt> (-24)</td>
</tr>
</tbody>
</table>
<p>Here, in the last arithmetic right shift, the MSB 1 instead of 0 was added to the left.</p>
<p>Undefined behavior occurs in C when <tt class="docutils literal">y &lt; 0</tt> or <tt class="docutils literal">y &gt;= word_size</tt>.</p>
</div>
<div class="section" id="using-shifts-and-masks">
<h2>Using Shifts and Masks</h2>
<p>Extract the 2nd most significant byte of an integer.</p>
<ul class="simple">
<li>Let x be <tt class="docutils literal">00110101 01100010 10011010 01010010</tt>.</li>
<li>First we do right shift operation <tt class="docutils literal">x &gt;&gt; 16</tt> and get <tt class="docutils literal">00000000 00000000 00110101 01100010</tt>.</li>
<li>And then we do bitwise <tt class="docutils literal">&amp;</tt> operation with <tt class="docutils literal">0xFF</tt> which in binary is <tt class="docutils literal">00000000 00000000 00000000 11111111</tt>.</li>
<li>The result of the above <tt class="docutils literal">&amp;</tt> operation is <tt class="docutils literal">00000000 00000000 00000000 01100010</tt>.</li>
</ul>
<p>Extract the sign bit of signed integer.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">(x&gt;&gt;31)</span> &amp; 1</tt> - need the <tt class="docutils literal">&amp; 1</tt> to clear out all other bits except LSB.</li>
</ul>
<p>Conditionals as Boolean expressions (assuming x is 0 or 1)</p>
<ul>
<li><p class="first"><tt class="docutils literal">if (x) a=y else a=z;</tt> which is same as <tt class="docutils literal">a = x ? y : z;</tt></p>
</li>
<li><dl class="first docutils">
<dt>Can be re-written (assuming arithmetic right shift) as:</dt>
<dd><p class="first last"><tt class="docutils literal">a = <span class="pre">((x&lt;&lt;31)</span> &gt;&gt; 31) &amp; y + <span class="pre">(((!x)&lt;&lt;31)</span> &gt;&gt; 31) &amp; z;</tt></p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="sign-extension-example">
<h2>Sign Extension Example</h2>
<p>Here, we will convert from smaller to larger integer data type. C automatically performs sign extension.</p>
<div class="highlight"><pre><span class="kt">short</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">;</span> <span class="c1">// 16 bits</span>
<span class="kt">int</span> <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 32 bits</span>
<span class="kt">short</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12345</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">iy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="13%" />
<col width="24%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head">Decimal</th>
<th class="head">Hex</th>
<th class="head">Binary</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>x</td>
<td>12345</td>
<td><tt class="docutils literal">30 39</tt></td>
<td><tt class="docutils literal">00110000 01101101</tt></td>
</tr>
<tr><td>ix</td>
<td>12345</td>
<td><tt class="docutils literal">00 00 30 39</tt></td>
<td><tt class="docutils literal">00000000 00000000 00110000 01101101</tt></td>
</tr>
<tr><td>y</td>
<td>-12345</td>
<td><tt class="docutils literal">CF C7</tt></td>
<td><tt class="docutils literal">11001111 11000111</tt></td>
</tr>
<tr><td>iy</td>
<td>-12345</td>
<td><tt class="docutils literal">FF FF CF C7</tt></td>
<td><tt class="docutils literal">11111111 11111111 11001111 11000111</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fractional-binary-numbers">
<h2>Fractional Binary Numbers</h2>
<p>Some examples:</p>
<ul class="simple">
<li><tt class="docutils literal">1011.101</tt><sub>2</sub>  is equal to <tt class="docutils literal">8 + 2 + 1 + 1/2 + 1/8</tt><sub>10</sub> .</li>
<li>5 and 3/4 = <tt class="docutils literal">101.11</tt><sub>2</sub> </li>
<li>2 and 7/8 = <tt class="docutils literal">10.111</tt><sub>2</sub> </li>
<li>63/64 = <tt class="docutils literal">0.111111</tt><sub>2</sub> </li>
</ul>
<p>Observations:</p>
<ul>
<li><p class="first">Divide by 2 by shifting right</p>
</li>
<li><p class="first">Multiply by 2 by shifting left</p>
</li>
<li><dl class="first docutils">
<dt>Numbers of form 0.111111111....<sub>2</sub>  are just below 1.0</dt>
<dd><p class="first last">1/2 + 1/4 + 1/8 + ... + 1/2<sup>i</sup>  + ... ---&gt; 1.0
Shorthand notation for all 1 bits to the right of binary point: 1.0 - e (epsilon)</p>
</dd>
</dl>
</li>
</ul>
<p>Limitations:</p>
<ul>
<li><p class="first">Can only exactly represent numbers that can be written as x * 2<sup>y</sup> </p>
</li>
<li><dl class="first docutils">
<dt>Other rational numbers have repeating bit representations, e.g.:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><tt class="docutils literal">1/3</tt> = 0.0101010101[01]<sub>...2</sub> </dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">1/5</tt> = 0.001100110011[0011]<sub>...2</sub> </li>
<li><tt class="docutils literal">1/10</tt> = 0.0001100110011[0011]<sub>...2</sub> </li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="fixed-point-representations">
<h2>Fixed Point Representations</h2>
<p>We might try representing fractional binary numbers by picking a fixed place for an implied binary point.</p>
<p>Lets do that, using 8-bit fixed point numbers as an example:</p>
<ul>
<li><dl class="first docutils">
<dt>#1 the binary point is between bits 2 and 3</dt>
<dd><p class="first last">b<sub>7</sub> b<sub>6</sub> b<sub>5</sub> b<sub>4</sub> b<sub>3</sub>  [.] b<sub>2</sub> b<sub>1</sub> b<sub>0</sub>  - The maximum value that can be represented with this is 31 and 7/8.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>#2: the binary point is between bits 4 and 5</dt>
<dd><p class="first last">b<sub>7</sub> b<sub>6</sub> b<sub>5</sub>  [.] b<sub>4</sub> b<sub>3</sub> b<sub>2</sub> b<sub>1</sub> b<sub>0</sub>  - The maximum value that can be represented with this is 7 and 31/32.</p>
</dd>
</dl>
</li>
</ul>
<p>The position of the binary point affects the range and precision of the representation.</p>
<ul class="simple">
<li>range: diff between largest and smallest numbers possible</li>
<li>precision: smallest possible difference between any two numbers</li>
</ul>
<p>One of the pros of fixed point representations is that it's simple. The same hardware that does integer arithmetic can do fixed point arithmetic.</p>
<p>But there is a bigger con to it. There is no good way to pick where the fixed point should be. Either the precision or the range has to be sacrificed each time. <strong>This is why fixed point representations are not used.</strong></p>
</div>
<div class="section" id="ieee-floating-point">
<h2>IEEE Floating Point</h2>
<p>It is analogous to scientific notation. For example, we represent 12000000 as 1.2 x 10<sup>7</sup> ; and 0.0000012 as 1.2 x 10<sup>-6</sup> . In C, these can be written as <tt class="docutils literal">1.2e7</tt> and <tt class="docutils literal"><span class="pre">1.2e-7</span></tt> respectively.</p>
<p>This is an IEEE standard established in 1985 for floating point arithmetic and is supported by all major CPUs today. This is fast at hardware level but is numerically well behaved.</p>
</div>
<div class="section" id="floating-point-representation">
<h2>Floating Point Representation</h2>
<p>Numerical form:</p>
<p>V<sub>10</sub>  = (-1)<sup>s</sup>  * M * 2<sup>E</sup> </p>
<ul class="simple">
<li>Sign bit s determines whether the number is negative or positive</li>
<li>Significand (mantissa) M normally a fraction value in range [1.0, 2.0)</li>
<li>Exponent E weights value by a (possibly negative) power of two</li>
</ul>
<p>Representation in memory</p>
<ul class="simple">
<li>MSB s is sign bit s</li>
<li>exp field encodes E (but is not equal to E)</li>
<li>frac field encodes M (but is not equal to M)</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="30%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>exp</td>
<td>frac</td>
</tr>
</tbody>
</table>
<p>Single precision: 32 bits</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>s (1)</td>
<td>exp (8)</td>
<td>frac (23 bits)</td>
</tr>
</tbody>
</table>
<p>Double precision: 64 bits</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>s (1)</td>
<td>exp (11)</td>
<td>frac (52 bits)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="normalization-and-special-values">
<h2>Normalization and Special Values</h2>
<p>Normalized means the mantissa M has the form 1.xxxxxx</p>
<ul class="simple">
<li>0.0011 x 2<sup>5</sup>  and 1.1 x 2<sup>3</sup> represent the same number, but the latter makes better use of the available bits.</li>
<li>Since we know that mantissa starts with a 1, we don't bother to store it thus saving a bit.</li>
</ul>
<p>Now, how do we represent <tt class="docutils literal">0.0</tt>? Or special/undefined values like <tt class="docutils literal">1.0/0.0</tt>?</p>
<p>For these cases, there are some special values reserved for <tt class="docutils literal">exp</tt> and <tt class="docutils literal">frac</tt>.</p>
<ul>
<li><p class="first">A bit pattern <tt class="docutils literal"><span class="pre">00...0</span></tt> represents zero</p>
</li>
<li><dl class="first docutils">
<dt>If <tt class="docutils literal">exp == <span class="pre">11...1</span></tt> and <tt class="docutils literal">frac == <span class="pre">00...0</span></tt>, it represents infinity</dt>
<dd><p class="first last">e.g. 1.0/0.0 = -1.0/-0.0 = +infinity, 1.0/-0.0 = -1.0/0.0 = -infinity</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If <tt class="docutils literal">exp == <span class="pre">11...1</span></tt> and <tt class="docutils literal">frac != <span class="pre">00...0</span></tt>, it represents <tt class="docutils literal">NaN</tt>: <cite>Not a Number</cite>.</dt>
<dd><p class="first last">Results from operations with undefined results, e.g. sqrt(-1), infinity, -infinity, infinity * 0</p>
</dd>
</dl>
</li>
</ul>
<p>Since, <tt class="docutils literal"><span class="pre">000...0</span></tt> and <tt class="docutils literal"><span class="pre">111...1</span></tt> are already reserved above as special values, we can't use them.</p>
<p>So, the condition: <tt class="docutils literal">exp != <span class="pre">000...0</span> and exp != <span class="pre">111...1</span></tt>.</p>
<p><strong>Exponent is coded as biased value:</strong> <tt class="docutils literal">E = exp - Bias</tt></p>
<ul>
<li><p class="first"><tt class="docutils literal">exp</tt> is an unsigned value ranging from 1 to 2<sup>k</sup>  - 2 (k == # bits in the <tt class="docutils literal">exp</tt>)</p>
</li>
<li><dl class="first docutils">
<dt>Bias = 2<sup>k-1</sup>  - 1</dt>
<dd><ul class="first last simple">
<li>Single precision: 127  (so exp: 1...254, E: -126...127)</li>
<li>Double precision: 1023 (so exp: 1...2046, E: -1022...1023)</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">This enables negative values for E, for representing very small values.</p>
</li>
</ul>
<p><strong>Significand coded with implied leading 1</strong>: <tt class="docutils literal">M = <span class="pre">1.xxx...x</span></tt><sub>2</sub> </p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xxx...x</span></tt>: the n bits of frac</li>
<li>Minimum when 000...0 (M = 1.0)</li>
<li>Maximum when 111...1 (M = 2.0 - e(epsilon))</li>
<li>Get extra leading bit for &quot;free&quot;</li>
</ul>
</div>
<div class="section" id="normalized-encoding-example">
<h2>Normalized Encoding Example</h2>
<p><strong>Value</strong>: <tt class="docutils literal">float f = 12345.0;</tt> (with single precision, 32-bits)</p>
<p><tt class="docutils literal">12345</tt><sub>2</sub>  = <tt class="docutils literal">11000000111001</tt><sub>2</sub>  = <tt class="docutils literal">1.1000000111001</tt><sub>2</sub>  x 2<sup>13</sup> </p>
<p><strong>Singnificand</strong>:</p>
<p>M    = <tt class="docutils literal">1.1000000111001</tt><sub>2</sub> frac = <tt class="docutils literal">10000001110010000000000</tt><sub>2</sub> </p>
<p><strong>Exponent</strong>: E = exp - Bias, so exp = E + Bias</p>
<p>E = 13, Bias = 127, so exp = 140 = <tt class="docutils literal">10001100</tt><sub>2</sub> </p>
<p>Result</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>s (1)</td>
<td>exp (8)</td>
<td>frac (23 bits)</td>
</tr>
<tr><td>0</td>
<td>10001100</td>
<td>10000001110010000000000</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="floating-point-operations">
<h2>Floating Point Operations</h2>
<p>Unlike the representation for integers, the representation for floating-point number is not exact because mantissa doesn't go on forever and stops at 23 bits or even 52 bits in double precision.</p>
<p>Basic idea:</p>
<ul>
<li><p class="first">First, compute the exact result</p>
</li>
<li><dl class="first docutils">
<dt>Then, round the result to make it fit into desired precision:</dt>
<dd><ul class="first last simple">
<li>Possibly overflow if the exponent is too large</li>
<li>Possibly drop least significant bits of significand to fit into <tt class="docutils literal">frac</tt></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>For rounding a value, there are many possible rounding modes like round towards zero, round down, round up, round to nearest value and round to even. With most of these values, errors start accumulating when rounding is repeated on the same value and this causes statistical bias. However, with round to even avoids this bias by rounding up about half the time and rounding down half the time. The <strong>default rounding mode for IEEE floating point is Round-to-even</strong>.</p>
<p>If overflow of the exponent occurs, result will be infinity or -infinity. Floats with value of inifinity, -inifinity and NaN can be used in operations but the result is usually still inifinity, -inifinity, or NaN.</p>
<p><strong>Floating point operations are not always associative or distributive, due to rounding!</strong></p>
<ul class="simple">
<li>(3.14 + 1e10) - 1e10 != 3.14 + (1e10 - 1e10)</li>
<li>1e20 * (1e20 - 1e20) != (1e20 * 1e20) - (1e20 * 1e20)</li>
</ul>
<p>Here, in the first example, in the LSH, when <tt class="docutils literal">(3.14 + 1e10)</tt> is computed, <tt class="docutils literal">3.14</tt> so small against <tt class="docutils literal">1e10</tt> that after adding these two and trying to fit it into the 23 bits, the least significant bits are dropped and thus the result is <tt class="docutils literal">1e10</tt>. So, LSH computes to <tt class="docutils literal">1e10 - 1e10 = 0</tt>. While on the RHS, <tt class="docutils literal">3.14 + (1e10 - 1e10) = 3.14</tt>.</p>
<p>In the second example, LSH simply computes to <tt class="docutils literal">0</tt>. While on the RHS, <tt class="docutils literal">(1e20 * 1e20)</tt> causes overflow and results infinity. So, RHS computes to <tt class="docutils literal">infinity - infinity = infinity</tt>.</p>
</div>
<div class="section" id="floating-point-in-c">
<h2>Floating Point in C</h2>
<p>C offers two levels of precision</p>
<ul class="simple">
<li><tt class="docutils literal">float</tt> - single precision (32-bit)</li>
<li><tt class="docutils literal">double</tt> - double precision (64-bit)</li>
</ul>
<p>Default rounding mode is round-to-even. There is a header file <tt class="docutils literal">#include &lt;math.h&gt;</tt> to get INFINITY and NAN constants.</p>
<p><strong>Equality comparisions ``==`` between floating point numbers are tricky, and ofter return unexpected results. AVOID THEM!!!</strong> Rather, subtract them and test if the value is small.</p>
</div>
<div class="section" id="coversion-between-data-types">
<h2>Coversion between data types</h2>
<p>Casting between int, float, and double changes the bit representation.</p>
<ul class="simple">
<li><tt class="docutils literal">int <span class="pre">--&gt;</span> float</tt> - May be rounded but overflow not possible since float can accomodate much larger values than int.</li>
<li><tt class="docutils literal">int <span class="pre">--&gt;</span> double</tt> - Exact conversion as long as int has &lt;= 53-bit word size since double has 52 bits for mantissa part (the leading 1 is not stored to the int can be 52+1 bit long) else rounding occurs.</li>
<li><tt class="docutils literal">float <span class="pre">--&gt;</span> double</tt> - Exact conversion since float is 32-bits and 64-bits, so double can definitely store a float representation in it.</li>
<li><tt class="docutils literal">double or float <span class="pre">--&gt;</span> int</tt> - Fractional part is truncated (rounded towards zero). And if the double/float representation is too large or too small, then int is generally set as Tmin or NaN or infinity...</li>
</ul>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>Zero</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>0</td>
<td>00000000</td>
<td>00000000000000000000000</td>
</tr>
</tbody>
</table>
<p>Normalized values</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="51%" />
<col width="42%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>1 to 2<sup>k</sup> -2</td>
<td>significand = 1.M</td>
</tr>
</tbody>
</table>
<p>Infinity</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>11111111</td>
<td>00000000000000000000000</td>
</tr>
</tbody>
</table>
<p>NaN</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>11111111</td>
<td>non-zero</td>
</tr>
</tbody>
</table>
<p>Denormalized values</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>00000000</td>
<td>significand = 0.M</td>
</tr>
</tbody>
</table>
<p>As with integers, float suffers from fixed number of bits available to represent them.</p>
<ul class="simple">
<li>Can get overflow/underflow, just like ints</li>
<li>Some &quot;simple fractions&quot; have no exact representations (e.g. 0.2)</li>
<li>Can also lose precision, unlike ints. Every operation gets a slightly wrong result.</li>
</ul>
<p>Mathematically equivalent ways of writing an expression may compute differet results.</p>
<p>Never test floating point values for equality.</p>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[S1 - Memory, Data and Addressing]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s1.html"/>
        <published>2013-04-30T00:00:00+05:30</published>
        <updated>2013-05-03T19:01:15+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s1.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <div class="section" id="performance">
<h2>Performance</h2>
<p>Performance is not just about CPU clock speed. Data and instructions reside in the memory and they must be fetched to the CPU from memory to operate upon.</p>
<p>CPU&lt;-&gt;Memory bandwidth can bottleneck performance. Two things can be done for this:</p>
<ul class="simple">
<li>Increase memory bandwidth so that more data can travel at a time. (DDR1 -&gt; DDR2 -&gt; DDR3)</li>
<li>Move less data into/out of the CPU. This can be achieved by putting a small amount of memory on the CPU itself (which is called cache memory).</li>
</ul>
</div>
<div class="section" id="binary-representations">
<h2>Binary Representations</h2>
<p>0s and 1s are represented by high and low voltage. It takes a little bit of time while changing the voltage and it is what limits the speed of the computing system. Electronics are designed to only care about the two specific voltages for 0 and 1 and not care about the voltages in between.</p>
</div>
<div class="section" id="representing-information-as-bits-and-bytes">
<h2>Representing information as bits and bytes</h2>
<p>We're going to group our binary digits into groups of eight which are called <strong>bytes</strong>. The range can be-</p>
<p><tt class="docutils literal">00000000</tt><sub>2</sub> - <tt class="docutils literal">11111111</tt><sub>2</sub></p>
<p>In decimal, the above range can be expressed as-</p>
<p><tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">255</tt><sub>10</sub></p>
<p>But using binary form to represent data in our programs can get tedious so hexadecimal form is used. Each hexadecimal digit is 4 bit long. A byte can also be represented as two hexadecimal digits. The range can be-</p>
<p><tt class="docutils literal">00</tt><sub>16</sub> - <tt class="docutils literal">FF</tt><sub>16</sub> (which is also same as <tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">225</tt><sub>10</sub>)</p>
<p>In C, <tt class="docutils literal">FA1D37B</tt><sub>16</sub> can be represented as <tt class="docutils literal">0xFA1D37B</tt> or <tt class="docutils literal">0xfa1d37b</tt>. This is an 8 digit hexadecimal number, so it is 8 x 4 bit = 32 bits or 4 bytes long number.</p>
</div>
<div class="section" id="byte-oriented-memory-organization">
<h2>Byte Oriented Memory Organization</h2>
<p>Memory is organized in bytes. Basically it is a big long array of bytes. Each byte has an address.</p>
</div>
<div class="section" id="machine-words">
<h2>Machine Words</h2>
<p>Machine has a &quot;word size&quot;.</p>
<p>Until recently, most machines used 32-bit (4-byte) words. It limited address to 4GB (2^32 bytes) and it has become too small for memory intensive applications.</p>
<p>Now, most x86 systems use 64-bit (8-byte) words which has potential address space of 2<sup>64</sup> ~ 1.8 x 10<sup>19</sup> bytes (18EB - exabytes).</p>
<p>For backward compatibility, many CPUs support different word sizes of 16-bit, 8-bit, 4-bit, 2-bit and 1-bit.</p>
</div>
<div class="section" id="word-oriented-memory-organization">
<h2>Word Oriented Memory Organization</h2>
<p>Addresses specify location of bytes in memory and each byte has an address.</p>
<p>In 32-bit systems, 4 bytes have to be grouped together into a word. And 64-bit systems have 8 byte words. So, what address do we give to those word with multiple bytes?</p>
<p>To maintain uniformity, address of a word is said to be the address of its first byte. [Refer to the last slide in <tt class="docutils literal"><span class="pre">lecture_slides_01_012-memorg.pdf</span></tt>]</p>
<p>Pointer is a data object that contains an address.</p>
</div>
<div class="section" id="byte-ordering">
<h2>Byte Ordering</h2>
<p>Say you want to store the 4-byte word <tt class="docutils literal">0xaabbccdd</tt>. In what order will the bytes be stored? There are two different conventions for that.</p>
<p>Big Endian and Little Endian. (Origin: Gulliver's Travels)</p>
<p><strong>Big Endian</strong>: The most significant byte of the number goes the lowest address.</p>
<p><strong>Little Endian</strong>: The least significant byte of the number goes the lowest address.</p>
<p>Example -</p>
<p>Variable has 4-byte representation <tt class="docutils literal">0x01234567</tt> and address of variable is <tt class="docutils literal">0x100</tt>.</p>
<p><strong>Big Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>01</td>
<td>23</td>
<td>45</td>
<td>67</td>
</tr>
</tbody>
</table>
<p><strong>Little Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>67</td>
<td>45</td>
<td>23</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>x86 architecture uses little endian convention.</p>
</div>
<div class="section" id="address-and-pointers-in-c">
<h2>Address and Pointers in C</h2>
<p>Variable declaration: <tt class="docutils literal">int x, y;</tt></p>
<p>The two variables will find two locations in memory in which to store 2 integers (1 word each).</p>
<p>Pointer declaration: <tt class="docutils literal">int *ptr;</tt></p>
<p>Declares a variable <tt class="docutils literal">ptr</tt> that is a pointer to a data item that in an integer. This will store an address rather than a value.</p>
<p>Assignment to a pointer: <tt class="docutils literal">ptr = &amp;x;</tt></p>
<p>This assigns ptr to point to the address where x is located. <tt class="docutils literal">&amp;</tt> is used to get the address of a variable.</p>
<p>Dereference operator (<tt class="docutils literal">*</tt>) is used to get the value pointed to by a pointer. <tt class="docutils literal">*ptr</tt> will give us the value at the memory address given by the value of <tt class="docutils literal">ptr</tt>.</p>
<p>Examples</p>
<ul class="simple">
<li>If <tt class="docutils literal">ptr = &amp;x;</tt> then <tt class="docutils literal">y = *ptr + 1</tt> is same as <tt class="docutils literal">y = x + 1</tt>.</li>
<li><tt class="docutils literal"><span class="pre">*(&amp;y)</span></tt> is equivalent to <tt class="docutils literal">y</tt>.</li>
</ul>
<p>We can do arithmetic on pointers.</p>
<p><tt class="docutils literal">ptr = ptr + 1</tt> - Since type of ptr is int and an int uses 4 bytes, C automatically adds (1 x 4 =) 4. But this can be dangerous if we don't exactly know what is present at the next memory address.</p>
</div>
<div class="section" id="assignment-in-c">
<h2>Assignment in C</h2>
<p>Left-Hand-Side = Right-Hand-Side</p>
<p>LHS must evaluate to a memory location (variable).</p>
<p>RHS must evaluate to a value (could be an address).</p>
<p><tt class="docutils literal">int x, y; x = y + 3;</tt> - Get value at y, add 3, put it in x</p>
<p><tt class="docutils literal">int *x; int y; x = &amp;y + 3;</tt> - Get address of y, add (3 x 4 =) 12 to it, put it in x</p>
<p><tt class="docutils literal">*x = y;</tt> - Here <tt class="docutils literal">*</tt> says to the compiler not to use <tt class="docutils literal">x</tt> itself as the variable rather get the value stored at x, interpret it as an address, put value of y at that address.</p>
</div>
<div class="section" id="arrays">
<h2>Arrays</h2>
<p>Arrays represent adjacent locations in memory that store same type of data objects. E.g. <tt class="docutils literal">int big_array[128];</tt> allocates 512 adjacent bytes (size of int- 4 bytes x 128) in memory.</p>
<div class="highlight"><pre><span class="cm">/* Lets assume that array starts at 0x00ff0000 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">array_ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">big_array</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="n">big_array</span><span class="p">;</span> <span class="cm">/* 0x00ff0000 */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* 0x00ff0000 */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="n">big_array</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="o">*</span><span class="n">array_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">array_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (but big_array[3] is incremented) */</span>
</pre></div>
<p>For <tt class="docutils literal">array_ptr = big_array;</tt>, when C sees that we are trying to assign an array to a different variable that is a pointer, it automatically assigns the memory address of the array.</p>
<p>The last one is a bit complicated. Lets first see RHS. <tt class="docutils literal">*array_ptr</tt> gets the value pointed to by the pointer <tt class="docutils literal">array_ptr</tt> which is <tt class="docutils literal">big_array[3]</tt> as seen in second-last line. Now in LHS, <tt class="docutils literal">*array_ptr</tt> says to go to the location pointed to by <tt class="docutils literal">array_ptr</tt> which is the address of <tt class="docutils literal">big_array[3]</tt>. So, in effect, it is equivalent to psuedo-code <tt class="docutils literal">big_array[3] = big_array[3] + 1</tt>.</p>
<p><tt class="docutils literal">array_ptr = &amp;big_array[130];</tt> - The array was only 128 element long but we are asking for index 130. But C doesn't give a fuck. It applies the same arithmetic calculation (adding 130 * size of int) and gives back address <tt class="docutils literal">0x00ff0208</tt>. Beware of this!</p>
<p>In general, <tt class="docutils literal">&amp;big_array[i]</tt> is same as <tt class="docutils literal">(big_array + i)</tt>, which implicitly computes <tt class="docutils literal">&amp;big_array[0] + i * <span class="pre">sizeof(big_array[0]);</span></tt></p>
</div>
<div class="section" id="representing-strings">
<h2>Representing strings</h2>
<p>A C-style string is represented by an array of bytes. Elements are one-byte ASCII codes for each character. A 0 byte marks the end of the array.</p>
<p><tt class="docutils literal">char S[4] = &quot;lola&quot;;</tt></p>
<p>Getting the address of an integer in the memory.</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">show_bytes</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\t</span><span class="s">0x%.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">show_int</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">show_bytes</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>First argument for <tt class="docutils literal">show_bytes</tt> function is the address of the starting location in memory. It is a pointer pointing to the character (which are of size one byte). Second argument is the length of bytes we want to print. <tt class="docutils literal">%p</tt> is for printing pointer and <tt class="docutils literal">%x</tt> is for printing a value as hex and <tt class="docutils literal">%.2x</tt> is for printing the value as two digit hex.</p>
<p>In <tt class="docutils literal">show_int</tt> function, while passing the first parameter, <tt class="docutils literal">&amp;x</tt> is address of an integer, but by <tt class="docutils literal">(char *) &amp;x</tt>, we are casting it as an address of character.</p>
</div>
<div class="section" id="boolean-algebra">
<h2>Boolean Algebra</h2>
<p>Encode &quot;True&quot; as 1 and &quot;False&quot; as 0.</p>
<ul class="simple">
<li>AND: A&amp;B = 1 when both A is 1 and B is 1</li>
<li>OR: A|B = 1 when either A is 1 or B is 1 or both</li>
<li>XOR: A^B = 1 when either A is 1 or B is 1, but not both</li>
<li>NOT: ~A = 1 when A is 0 and vice-versa</li>
</ul>
<p>DeMorgan's Law: <tt class="docutils literal">~(A|B) = ~A &amp; ~B</tt></p>
</div>
<div class="section" id="bitwise-operations">
<h2>Bitwise Operations</h2>
<p>Bitwise operators <tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">|</tt>, <tt class="docutils literal">^</tt>, <tt class="docutils literal">~</tt> are available in C.
They can be applied to any &quot;integral&quot; data types (long, int, short, char). Operations are applied bitwise.</p>
<p>Examples:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x41</span><span class="p">;</span> <span class="cm">/* 0x41 -&gt; 01000001 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>         <span class="cm">/* 10111110 -&gt; 0xBE */</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>    <span class="cm">/* 0x00 -&gt; 00000000 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>         <span class="cm">/* 11111111 -&gt; 0xFF */</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x69</span><span class="p">;</span> <span class="cm">/* 0x69 -&gt; 01101001 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x55</span><span class="p">;</span> <span class="cm">/* 0x55 -&gt; 01010101 */</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>      <span class="cm">/* 01000001 -&gt; 0x41 */</span>
</pre></div>
</div>
<div class="section" id="logic-operations">
<h2>Logic Operations</h2>
<p>Logical operators in C: <tt class="docutils literal">&amp;&amp;</tt>, <tt class="docutils literal">||</tt> and <tt class="docutils literal">!</tt>. <tt class="docutils literal">0</tt> is viewed as false and any non-zero value is treated as true. Early termination occurs where possible.</p>
<p>Examples:</p>
<ul class="simple">
<li><tt class="docutils literal">!0x41</tt>         --&gt; <tt class="docutils literal">0x00</tt></li>
<li><tt class="docutils literal">!0x00</tt>         --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">0x69 &amp;&amp; 0x55</tt>  --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">0x00 &amp;&amp; 0x55</tt>  --&gt; <tt class="docutils literal">0x00</tt></li>
<li><tt class="docutils literal">0x69 || 0x55</tt>  --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">p &amp;&amp; *p++</tt> (avoids null pointer access <tt class="docutils literal">0x00000000</tt>)</li>
</ul>
<p>In the last one, if p is a null pointer (false), then the <cite>and</cite> operation will short-circuit and <tt class="docutils literal">*p++</tt> won't be executed. It is short for <tt class="docutils literal">if (p) { <span class="pre">*p++;</span> }</tt>.</p>
</div>
<div class="section" id="representing-manipulating-sets">
<h2>Representing &amp; Manipulating Sets</h2>
<p>Bit vectors can be used to represent sets.</p>
<p>Width w bit vector represents of {0,...,w-1}</p>
<p>a<sub>j</sub>= 1 if j in A - each bit in the vector represents the absence (0) or presence (1) of an element in the set.</p>
<blockquote>
<p>01101001</p>
<p>76543210</p>
</blockquote>
<p>The set here is {0, 3, 5, 6}.</p>
<blockquote>
<p>01010101</p>
<p>76543210</p>
</blockquote>
<p>And the set here is {0, 2, 4, 6}.</p>
<p>Operations:</p>
<ul class="simple">
<li><tt class="docutils literal">&amp;</tt> Intersections        --&gt; 01000001 {0, 6}</li>
<li><tt class="docutils literal">|</tt> Union                --&gt; 01111101 {0, 2, 3, 4, 5, 6}</li>
<li><tt class="docutils literal">^</tt> Symmetric difference --&gt; 00111100 {2, 3, 4, 5}</li>
<li><tt class="docutils literal">~</tt> Complement           --&gt; 10101010 {1, 3, 5, 7}</li>
</ul>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[JavaScript Basics]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/javascript-basics.html"/>
        <published>2013-03-27T00:00:00+05:30</published>
        <updated>2013-04-03T05:48:41+05:30</updated>
        <id>http://vivek.im/notes/notes/javascript-basics.html</id>
        <category scheme="http://vivek.im/notes/tag/javascript/" term="javascript" label="javascript" />
        <category scheme="http://vivek.im/notes/tag/basics/" term="basics" label="basics" />
        <category scheme="http://vivek.im/notes/tag/notes/" term="notes" label="notes" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>The core language features of JavaScript are defined in ECMA-262 as a pseudolanguage named ECMAScript. ECMAScript contains all of the basic syntax, operators, data types, and objects necessary to complete basic computing tasks, though it provides no way to get input or to produce output. Understanding ECMAScript and its intricacies is vital to a complete understanding of JavaScript as implemented in web browsers.</p>
<p><strong>Data types</strong></p>

<ul>
<li>undefined - for undefined variables</li>
<li>null - empty object pointer</li>
<li>boolean - true or false</li>
<li>string</li>
<li>number</li>
<li>object</li>
<li>function</li>
</ul>
<p>Variable initiliazation</p>

<pre><code>::js
var abc = &quot;lola&quot;; // creates local variable
xyz = &quot;loli;&quot; // creates global variable (bad)</code></pre>
<p>Type checking</p>

<pre><code>::js
typeof any_uninitialized_variable; // undefined

var spam;
typeof undefined; // undefined</code></pre>
<p>undefined is unpredictable. You won&#39;t know if the variable has been just initialized or it hasn&#39;t.</p>

<ul>
<li>Don&#39;t set value of any variable to undefined explicitly.</li>
<li>Any time an object is expected but is not available, null should be used in its place.</li>
</ul>
<p>Because storing floating-point values uses twice as much memory as storing integer values, ECMAScript always looks for ways to convert values into integers.</p>

<pre><code>::js
var someNum = 22.0; // interpreted as integer 22</code></pre>
<p>There is a special numeric value called <strong>NaN</strong>, short for Not a Number, which is used to indicate when an operation intended to return a number has failed (as opposed to throwing an error).</p>

<ul>
<li>Dividing a number by 0 gives NaN.</li>
<li>Any operation involving NaN returns NaN.</li>
</ul>
<p>NaN&#39;s peculiar behavior.</p>

<pre><code>::js
NaN == NaN; // returns false</code></pre>
<p>Use isNaN(); function to check for NaN.</p>

<pre><code>::js
isNaN(&quot;11&quot;); // false - can be converted to 11
isNaN(&quot;lola&quot;); // true - cannot be converted to a number
isNaN(true); // false - can be converted to 1</code></pre>
<p><strong>Numbers</strong></p>

<pre><code>::js
Number(&quot;100 Cats&quot;); // NaN
Number(&quot;100&quot;); // 100
Number(&quot;&quot;); // 0
Number(true); // 1
Number(&quot;000010&quot;); // 10 (leading 0s are ignored)</code></pre>
<p>Because of the complexities and oddities of the Number() function when converting strings, the parseInt() function is usually a better option when you are dealing with integers.</p>

<pre><code>::js
parseInt(&quot;100 Cats 323&quot;); // 100
parseInt(&quot;Cats 100 203&quot;); // NaN</code></pre>
<p>If this first character isnt a number, the minus sign, or the plus sign, parseInt() always returns NaN, which means the empty string returns NaN (unlike with Number(), which returns 0).</p>
<p>Radix can be passed as second argument to parseInt(). It is a good idea to pass the value (10 for decimals, 2 for binary, 8 for octal and 16 for hexadecimal) to avoid any errors.</p>
<p><strong>Strings</strong></p>
<p>Strings are immutable in ECMAScript like in Python. To change the string value held by a variable, it must be destroyed and replaced with the new one.</p>
<p>A value can be converted to string easily by adding &ldquo;&rdquo; to it.</p>

<pre><code>::js
9 + &quot;&quot;; // &quot;9&quot;</code></pre>
<p><strong>Boolean</strong></p>
<p>Logical NOT can be performed with ! sign before the value.</p>
<p>Logical AND: &amp;&amp;</p>
<p>Logical OR: ||</p>

<pre><code>::js
null == undefined; //true
&quot;NaN&quot; == NaN; //false
5 == NaN; //false
NaN == NaN; //false
NaN =! NaN; //true
false == 0; //true
true == 1; //true
true == 2; //false
undefined == 0; //false
null == 0; //false
&quot;5&quot; == 5; //true
&quot;5&quot; === 5; //false</code></pre>
<p>=== does comparison without type conversion.</p>
<p><strong>Conditional Operator</strong></p>

<pre><code>::js
variable = boolean_expression ? true_value : false_value;
var max = (num1 &gt; num2) ? num1 : num2;</code></pre>
<p><strong>if Statement</strong></p>

<pre><code>::js
if (condition) {
    statement1;
} else if {
     statement2;
} else {
     statement3;
}</code></pre>
<p><strong>do Statement</strong></p>

<pre><code>::js
do {
    statement;
} while (expression);</code></pre>
<p><strong>while Statement</strong></p>

<pre><code>::js
while (expression) {
    statement;
}</code></pre>
<p><strong>for Statement</strong></p>
<p>Nothing can be done with a for loop that cant be done using a while loop. The for loop simply encapsulates the loop-related code into a single location.</p>

<pre><code>::js
for (initialization; expression; post-loop-expression) {
    statement;
}

for (var i=0; i&lt;=5; i++) {
    alert(i);
}</code></pre>
<p><strong>for-in Statement</strong></p>

<pre><code>::js
for (property in expression) {
    statement;
}</code></pre>
<p><strong>Labeled Statement</strong></p>
<p>Statements can be labeled using following syntax. Mostly used in loops to break out the outer loop.</p>

<pre><code>::js
label: statement;</code></pre>
<p><strong>with Statement</strong></p>
<p>The with statement sets the scope of the code within a particular object.</p>

<pre><code>::js
with (expression) {
    statement;
}</code></pre>
<p>Example:</p>

<pre><code>::js
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;</code></pre>
<p>can be rewritten as:</p>

<pre><code>::js
var qs = search.substring(1);
var hostName = hostname;
var url = href;</code></pre>
<p>Note: It is widely considered a poor practice to use the with statement in production code because of its negative performance impact and the difficulty in debugging code contained in the with statement.</p>
<p><strong>switch Statement</strong></p>

<pre><code>::js
switch (expression) {
    case value/expression: statement;
    break;
    case value/expression: statement;
    break;
    default: statement;
}</code></pre>
<p>Each case in a switch statement says, If the expression is equal to the value, execute the statement. The break keyword causes code execution to jump out of the switch statement. Without the break keyword, code execution falls through the original case into the following one.</p>

<h2 id="toc_0">Functions</h2>

<pre><code>::js
function functionName(arg1, arg2,, argN) {
    statements
}</code></pre>
<p>Function arguments in ECMAScript dont behave in the same way as function arguments in most other languages. <strong>An ECMAScript function doesnt care how many arguments are passed in</strong>, nor does it care about the data types of those arguments. Just because you define a function to accept two arguments doesnt mean you can pass in only two arguments. You could pass in one or three or none, and the interpreter wont complain. This happens because arguments in ECMAScript are represented as an array internally.</p>
<p>There is an arguments object that can be accessed inside a function which contains all the passed in arguments. Individual arguments can be accessed by using index notation.</p>
<p>All arguments in ECMAScript are passed by value. It is not possible to pass arguments by reference.</p>
<p>Functions that don&#39;t return any value explicitly actually return undefined.</p>
<p><strong>Primitive and Reference Values</strong></p>
<p>ECMAScript variables may contain two different types of data: primitive values and reference values.</p>
<p><strong>Primitive Values</strong> - Simple atomic pieces of data. These are accessed by value. These are undefined, null, number, string and boolean.</p>
<p><strong>Reference Values</strong> - Objects that may be made up of multiple values. JavaScript does not permit direct access of memory locations, so direct manipulation of the objects memory space is not allowed. When you manipulate an object, <strong>youre really working on a reference to that object rather than the actual object itself</strong>. For this reason, such values are said to be accessed by reference.</p>

<ul>
<li>When copying primitive values, stored value in one variable is hard copied to the other variable. They then have nothing to do with each other.</li>
<li>Whereas when copying reference values, pointer from one variable is simply copied to the other variable, both of which point to the same object stored on the heap. Changes made to the object with access from any of the variable affects all the other ones.</li>
</ul>
<p>Now, let&#39;s focus on argument passing. All function arguments in ECMAScript are passed by values. This means that the value outside of the function is copied into an argument on the inside of the function the same way a value is copied from one variable to another.</p>
<p>When the argument is passed by value, the value is copied into a local variable (a named argument is available and in arguments object). This happens in accordance to the rules mentioned above.</p>
<p>In case of reference values when passed in arguments, a local copy of the pointer is made but they both still point to the same object. Changes made to the object inside the function will reflect even outside of it.</p>
<p>It can be checked whether the variable contains primitive or reference value by using isinstanceof operator with following syntax.</p>

<pre><code>::js
result = variable isinstanceof constructor;

person isinstanceof Object;
colors isinstanceof Array;</code></pre>
<p>All reference values, by definition, are instances of Object, so the instanceof operator always returns true when used with a reference value and the Object constructor. Similarly, if instanceof is used with a primitive value, it will always return false, because primitives arent objects.</p>
<p><strong>Execution Context and Scope</strong></p>
<p>There are mainly two execution context (or scope) which are at global and function level. Also the with statement and the catch block in try-catch statement have their own execution context.</p>
<p>If var is omitted while initializing a variable inside of a function, it is created in global context.</p>

<h2 id="toc_1">Reference Types</h2>
<p>A reference value (object) is an instance of a specific reference type. In ECMAScript, reference types are structures used to group data and functionality together and are often incorrectly called classes.</p>
<p><strong>Object Type</strong></p>
<p>Can be created in two ways:</p>

<pre><code>::js
var person = new Object();
person.name = &quot;lola&quot;;

//or

var person = {
    name: &quot;lola&quot;;
}</code></pre>
<p>Object properties can be accessed using dot notation as well as using bracket notation.</p>

<pre><code>::js
person.name;
person[&quot;name&quot;]; // both are same</code></pre>
<p><strong>Array Type</strong></p>
<p>ECMAScript arrays are dynamically sized. A same array can hold any data type in each slot. Can be created in following ways:</p>

<pre><code>::js
var colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;);
var colos = Array(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;);
var colors = [&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;];</code></pre>
<p>Elements can be accessed using bracket notation. Arrays have length property with which the size of an array can be known. By setting the length property, you can easily remove items from or add items to the end of the array.</p>
<p><strong>Array Methods</strong></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Scala Basics]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/scala-basics.html"/>
        <published>2013-03-27T00:00:00+05:30</published>
        <updated>2013-04-03T05:55:37+05:30</updated>
        <id>http://vivek.im/notes/notes/scala-basics.html</id>
        <category scheme="http://vivek.im/notes/tag/scala/" term="scala" label="scala" />
        <category scheme="http://vivek.im/notes/tag/basics/" term="basics" label="basics" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>Imperative Programming is about</p>

<ul>
<li>modifying mutable variables,</li>
<li>using assignments</li>
<li>and control structures such as if-then-else, loops, breaks, continue, return.</li>
</ul>
<p>Pure imperative programming is limited by the Von Neumann bottleneck:</p>

<blockquote>
<p>One tends to conceptualize data structures word-by-word.</p>
</blockquote>
<p>We need other techniques for dening high-level abstractions such as collections, polynomials, geometric shapes, strings, documents.</p>
<p>A theory consists of one or more data types, operation on these data types and laws that describe the relationship between values and operations.</p>
<p>Normally, a theory doesn&#39;t describes mutations!</p>
<p>Functional Programming is about</p>

<ul>
<li>In a restricted sense, it means programming without mutable variables, assignments, loops and other imperative control stuctures.</li>
<li>In a wider sense, functional programming means focusing on the functions to construct elegant programs.</li>
<li>In particular, functions can be values that are produced, consumed and composed.</li>
<li>Functions are first class citizens. They can be defined anywhere, including inside other functions.</li>
<li>Functions like any other value, passed as parameter to functions and returned as results. As for other values, there exists a set operators to compose
functions.</li>
</ul>
<p>Functional Programming is becoming increasingly popular because it oers an attractive method for exploiting parallelism for multicore and cloud computing.</p>
<p>In a parallel environment, when multiple threads try to access and mutate a shared mutable state, problems arises. Though there are ways to solve it, it is not always easy and elegant as desired. In functional programming, by eliminating the use of mutable states these problems can be easily solved.</p>
<p>Functions can be defined as:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span> <span class="n">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">square</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>

<span class="cm">/* Here, the return type is defined as well. */</span>
<span class="k">def</span> <span class="n">power</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
<p><strong>Call by value (CBV)</strong> - All the arguments are evaluated to a simple value and then passed on to the function body as soon as the function is ran.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">example</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm">Evaluated as-</span>
<span class="cm">example(2+3, 7) -&gt; example(5, 7) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm">*/</span>
</pre></div>
<p><strong>Call by name (CBN)</strong> - All the arguments are passed to the function body as it is and evaluation is done by the code within the function body.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Evaluated as-</span>
<span class="cm"> * example(2+3, 7) -&gt; (2+3) * (2+3) -&gt; 5 * (2+3) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm"> */</span>
</pre></div>
<p>If CBV evaluation of an expression <em>e</em> terminates, then CBN evaluation of <em>e</em> terminates too.</p>
<p>The other direction is not true.</p>
<p>Non-termination example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>

<span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">loop</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Here, the loop resolves to itself infinitely.</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBN:</span>
<span class="cm"> * first(1, loop) -&gt; 1</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBV:</span>
<span class="cm"> * first(1, loop) -&gt; first(1, loop) -&gt; first(1, loop)....</span>
<span class="cm"> */</span>
</pre></div>
<p>Scala normally uses call-by-value.</p>
<p>But if the type of a function parameter starts with =&gt;, it uses call-by-name.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">consOne</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="cm">/* Here, x is evaluated as CBV by default and y is evaluated as CBN which we explicitly forced it to. */</span>
</pre></div>
<p><strong>Conditional Expressions</strong></p>
<p>if-else in Scala is used for expressions, not statements.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span>
</pre></div>
<p>Rewrite rules for Booleans (e is an arbitrary expression):</p>
<div class="highlight"><pre><span class="cm">/* !true        --&gt; false</span>
<span class="cm"> * !false       --&gt; true</span>
<span class="cm"> * true &amp;&amp; e    --&gt; e</span>
<span class="cm"> * false &amp;&amp; e   --&gt; false</span>
<span class="cm"> * true || e    --&gt; true</span>
<span class="cm"> * false || e   --&gt; e</span>
<span class="cm"> */</span>
</pre></div>
<p><strong>Value Definitions</strong></p>
<p>The <code>def</code> form is &ldquo;by name&rdquo;, its right hand side evaluated on each use.</p>
<p>There is also a <code>val</code> for, which is &ldquo;by value&rdquo;. Example-</p>
<div class="highlight"><pre><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div>
<p>The right hand side of a val definition is evaluated at the point of the definition itself.</p>
<p>Afterwards the name refers to the value. Here y refers to 4, not square(2).</p>
<p><strong>Difference between val and def</strong></p>
<p>The difference becomes apparent when the right hand side does not terminate.</p>
<div class="highlight"><pre><span class="cm">/* This works fine. */</span>
<span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">loop</span>
<span class="k">def</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>

<span class="cm">/* However, this will get stuck in an infinite loop since the interpreter tries to evaluate the loop right at the point of definition. */</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>
</pre></div>
<p>&amp;&amp; and || implementation as functions-</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">and</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span>
<span class="k">def</span> <span class="n">or</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">true</span>
</pre></div>
<p><strong>Return type is required when calling a function recursively.</strong></p>
<p><strong>Blocks in Scala</strong></p>
<p>A block is defined by curly braces {&hellip;.}.</p>
<div class="highlight"><pre><span class="o">{</span>
    <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div>
<p>It constains a sequence of definition or expressions.
The last element of a block is an expression that denes its value.
This return expression can be preceded by auxiliary denitions.
Blocks are themselves expressions; a block may appear everywhere an expression can.</p>

<ul>
<li>The denitions inside a block are only visible from within the block.</li>
<li>The denitions inside a block shadow denitions of the same names outside the block.</li>
</ul>
<p><strong>Semicolons</strong></p>
<p>In Scala, semicolons at the end of a line is optional in most cases. If there are more than one statements in one line, then they need to be separatd with a semi-colon.</p>
<p><strong>Semicolons and inx operators</strong></p>
<p>One issue with Scalas semicolon convention is how to write expressions that span several lines. For instance-</p>
<div class="highlight"><pre><span class="n">someLongExpression</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>

<span class="cm">/* would be interpreted as */</span>

<span class="n">someLongExpression</span><span class="o">;</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>
</pre></div>
<p>Two ways to overcome the problem.</p>
<div class="highlight"><pre><span class="cm">/* Multiline expression can be written inside parentheses. */</span>
<span class="o">(</span><span class="n">someLongExpression</span>
    <span class="o">+</span> <span class="n">someOtherExpression</span><span class="o">)</span>

<span class="cm">/* Or operator can be written on the first line because this tells the Scala compiler that the expression is not yet finished. */</span>
<span class="n">someLongExpression</span> <span class="o">+</span>
<span class="n">someOtherExpression</span>
</pre></div>
<p><strong>Tail Recursion</strong></p>
<p>If a function calls itself as its last action, the function&#39;s stack frame can be reused. This is called tail recursion. Tail recursive functions are iterative processes.</p>
<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sucient for both functions. Such calls are called tail-calls.</p>
<p>Example of non-tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
<p>Example of tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">def</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">accum</span>
        <span class="k">else</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">loop</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
<p>In the first example, the return value <code>x * factorial(x-1)</code> has a pending calculation of x multiplied by factorial of (x-1) which would have to wait until that factorial has been computed and thus that recursive chain keeps on growing.</p>
<p>However, in the second example, for the return value <code>fac_loop(accum * n, n - 1)</code> the function calls itself and there are no pending computation to be done, so the further function calls can take place in the same stack frame without growing like crazy like in the previous example.</p>
]]>
        </content>
    </entry>
</feed>