<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Study Notes</title>
    <link href="http://vivek.im/notes/feed.xml" rel="self" />
    <link href="http://vivek.im/notes/" />
    <updated>2013-05-13T04:55:39+05:30</updated>
    <id>http://vivek.im/notes/</id>
    <entry>
        <title type="html"><![CDATA[M101 - MongoDB for Developers]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/mongodb.html"/>
        <published>2013-05-09T00:00:00+05:30</published>
        <updated>2013-05-13T04:55:39+05:30</updated>
        <id>http://vivek.im/notes/notes/mongodb.html</id>
        <category scheme="http://vivek.im/notes/tag/mongodb/" term="mongodb" label="mongodb" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>In MongoDB, there can be multiple databases. You can switch to a different database using <tt class="docutils literal">use &lt;db_name&gt;</tt> command in mongo shell. If the database doesn't exits, it will be automatically created and selected.</p>
<p>A database can have multiple collections. And each collections can have multiple <cite>documents</cite> which are basically BSON (like JSON) objects (dicts or key-value associations). BSON is a super-script of JSON syntax. Apart from JSON elements, BSON has few other stuff like binary data storage, UTC datetime, unique <tt class="docutils literal">ObjectId</tt>, regex, etc.</p>
<p>In Mongo, different documents can have different schema, so it is <strong>schemaless</strong>.</p>
<p>All the documents in a collection (coll_1) can be retrieved by - <tt class="docutils literal"><span class="pre">db.coll_1.find();</span></tt>.</p>
<p>A document can be stored in a collection (coll_1) by - <tt class="docutils literal"><span class="pre">db.coll_1.save({name:&quot;Lola&quot;,</span> favs: [&quot;harry potter&quot;, &quot;kill <span class="pre">bill&quot;]});</span></tt>.</p>
<p>One document can be fetched using <tt class="docutils literal">findOne()</tt> method. E.g. <tt class="docutils literal">db.coll_1.findOne()</tt>.</p>
<p>Output can be prettified using <tt class="docutils literal">pretty()</tt> method on any query. E.g. <tt class="docutils literal"><span class="pre">db.coll_1.find().pretty()</span></tt>.</p>
<p>When a document is inserted, MongoDB required that every document has an <tt class="docutils literal">_id</tt> field in it. It is a primary key field therefore it is unique and immutable. It is an ObjectId instance. If <tt class="docutils literal">_id</tt> isn't present while insertion, an ObjectId instance will be created and inserted with it. Any other value such as number, string, etc can be used for <tt class="docutils literal">_id</tt> field as well but it has to be unique. If an object with a suplicate <tt class="docutils literal">_id</tt> field is inserted, it overwrites the original document.</p>
<div class="section" id="crud-operations">
<h2>CRUD Operations</h2>
<p>CRUD - Create, Read, Update and Delete.</p>
<p>In MongoDB terms =&gt; Insert, Find, Update and Remove.</p>
<p>MongoDB doesn't has its own language analogous to SQL. MongoDB CRUD operations exist as method/functions in programming language APIs.</p>
<p>Mongo shell is an interactive javascript interpreter.</p>
<p>When a statement such as <tt class="docutils literal">db.coll_1.findOne()</tt> is run, here <tt class="docutils literal">db</tt> is a handle for the currently selected database.</p>
<p><strong>Inserting Docs</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.insert({name:</span> &quot;Booker DeWitt&quot;, mission: &quot;Save <span class="pre">Elizabeth&quot;});</span></tt></p>
<p><strong>findOne operation</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.findOne();</span></tt> gives back a random document from the collection.</p>
<p>We can also give arguments to findOne. E.g. <tt class="docutils literal"><span class="pre">db.coll_1.findOne({name:</span> &quot;Lola&quot;, <span class="pre">subject:&quot;CS&quot;});</span></tt> will find one document with field <tt class="docutils literal">name: &quot;Lola&quot;</tt> and <tt class="docutils literal"><span class="pre">subject:&quot;CS&quot;</span></tt> in it and nothing if no result is found.</p>
<p>A second argument can also be given, which specifies which fields we want back in the result. E.g. <tt class="docutils literal"><span class="pre">db.coll_1.findOne({name:</span> <span class="pre">&quot;Lola&quot;},</span> {name: true, profession: true, _id: <span class="pre">false});</span></tt>.</p>
<p>Above query will return a document with <tt class="docutils literal">name: &quot;Jones&quot;</tt> field in it and the document will only contain fields <tt class="docutils literal">name</tt> and <tt class="docutils literal">profession</tt> in it. By default, <tt class="docutils literal">_id</tt> is set to true, but we can hide <tt class="docutils literal">_id</tt> by setting it to false.</p>
<p><strong>find Operation</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find();</span></tt> returns all the documents present in the <tt class="docutils literal">coll_1</tt> collection. In mongo shell, 20 documents are returned in batches at a time.</p>
<p><tt class="docutils literal">find</tt> method can also 2 arguments just like <tt class="docutils literal">findOne</tt>.</p>
<p>If you want to find a document in a collection and you are sure that only one document for the query exists, then use <tt class="docutils literal">findOne</tt> instead, since it will stop searching for database after the first result is found. Whereas, <tt class="docutils literal">find</tt> searches the entire database to find all the possible results.</p>
<p><strong>$gt and $lt operations</strong></p>
<p><tt class="docutils literal">db.coll_1.find({ score: { $lt: 100 } });</tt> returns all the documents with <tt class="docutils literal">score</tt> field values less than 100.</p>
<p><tt class="docutils literal">db.coll_1.find({ score: { $gt: 90 } });</tt> returns all the documents with <tt class="docutils literal">score</tt> field values greater than 90.</p>
<p><tt class="docutils literal">db.coll_1.find({ score: { $gte: 90, $lt: 100 } });</tt> returns all the documents with <tt class="docutils literal">score</tt> field values greater than or equal to 90 and less than 100.</p>
<p><tt class="docutils literal">db.coll_1.find({ score: { $lte: 100 }, type: &quot;essay&quot; });</tt> returns all the documents with <tt class="docutils literal">score</tt> field values less than or equal to 100 and <tt class="docutils literal">type</tt> field value <tt class="docutils literal">essay</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">$gt</tt> - greater than</li>
<li><tt class="docutils literal">$lt</tt> - less than</li>
<li><tt class="docutils literal">$gte</tt> - greater than or equal to</li>
<li><tt class="docutils literal">$lte</tt> - less than or equal to</li>
</ul>
<p>These operations also work on strings (uses utf8 encoding values for comparision).</p>
<p><strong>Using regexes, $exists, $type operations</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({profession:</span> {$exists: true} });</tt> will return all documents in which <tt class="docutils literal">profession</tt> field is present.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({name:</span> {$type: 2} });</tt> will return all documents in which <tt class="docutils literal">name</tt> field only has string value.</p>
<p>Numeric encoding for various data types as specified in BSON spec are used for querying for specific data types.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({name:</span> { $regex: &quot;^Ta&quot; });</tt> qill return all documents in which <tt class="docutils literal">name</tt> field starts with &quot;Ta&quot; string. Any regex pattern can be used here.</p>
<p><strong>$or, $and operation</strong></p>
<p><tt class="docutils literal">db.coll_1.find({ $or: [ {name: {$regex: <span class="pre">&quot;e$&quot;}},</span> {age: {$exists: true}} ] });</tt> will return all documents where <tt class="docutils literal">name</tt> field ends with string &quot;e&quot; or <tt class="docutils literal">age</tt> field is present.</p>
<p><tt class="docutils literal">$or</tt> is a prefix operator. It takes separate queries in an array and returns documents which match any of the separate queries. In effect, it performs union of queries.</p>
<p><tt class="docutils literal">$and</tt> works very similar to <tt class="docutils literal">$or</tt> operator.</p>
<p><tt class="docutils literal">db.coll_1.find({ $and: [ {name: {$gt: <span class="pre">&quot;C&quot;}},</span> {profession: &quot;Engineer&quot;} ] });</tt> will return all the documents where name is greater than (starts with) letter C and <tt class="docutils literal">profession</tt> field is &quot;Engineer&quot;.</p>
<p>But <tt class="docutils literal">$and</tt> isn't frequently used since the above operation can be writter in a simpler manner such as <tt class="docutils literal"><span class="pre">db.coll_1.find({name:</span> {$gt: <span class="pre">&quot;C&quot;},</span> profession: <span class="pre">&quot;Engineer&quot;});</span></tt></p>
<p><strong>Querying inside arrays with $all and $in operators</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({favorite:</span> <span class="pre">&quot;beer&quot;});</span></tt> will normally find all the documents in which field <tt class="docutils literal">favorite: &quot;beer&quot;</tt> exists. But if the <tt class="docutils literal">favorite</tt> field is an array, then it will look inside array if &quot;beer&quot; exists.</p>
<p>If we want to look for multiple values in an array, <tt class="docutils literal">$all</tt> operator can be used.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({favorite:</span> {$all: [&quot;beer&quot;, &quot;cheese&quot;] <span class="pre">}});</span></tt> will find documents in which <tt class="docutils literal">favorite</tt> field is an array and it contains both &quot;beer&quot; and &quot;cheese&quot; elements. It can contain other elements as well.</p>
<p>If we want to look for either of the multiple values in an array, <tt class="docutils literal">$in</tt> operator can be used.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({favorite:</span> {$in: [&quot;beer&quot;, &quot;cheese&quot;] <span class="pre">}});</span></tt> will find documents in which <tt class="docutils literal">favorite</tt> field is an array and it contains either &quot;beer&quot; or &quot;cheese&quot; elements.</p>
<p><strong>Querying for nested documents with dot notation</strong></p>
<p>Suppose we have a document <tt class="docutils literal">{name: &quot;Lola&quot;, email: {work: &quot;work&#64;lola.com&quot;, personal: <span class="pre">&quot;me&#64;lola.com&quot;}}</span></tt> and we want to find documents with work email address to be &quot;<a class="reference external" href="mailto:work&#64;lola.com">work&#64;lola.com</a>&quot;, following query with dot notation can be used.</p>
<p><tt class="docutils literal">db.coll_1.find({ email.work: <span class="pre">&quot;work&#64;lola.com&quot;});</span></tt></p>
<p><strong>Cursors</strong></p>
<p>When a query is executed, a cursor is contructed and returned. Interactive shell is configured to print documents by iterating over the cursor. But a cursor can be hold onto with <tt class="docutils literal">cur = <span class="pre">db.people.find();</span> null;</tt>. <tt class="docutils literal">null;</tt> is tacked on to prevent printing the elements. <tt class="docutils literal">cur.hasNext()</tt> returns true if there is document present next. <tt class="docutils literal">cur.next()</tt> returns the next document. <tt class="docutils literal">find()</tt> method can be implemented as <tt class="docutils literal">while <span class="pre">(cur.hasNext())</span> <span class="pre">printjson(cur.next());</span></tt>.</p>
<p>A <strong>limit</strong> can be imposed on a cursor by appending <tt class="docutils literal">cursor()</tt> method over it. For example, on above cursor <tt class="docutils literal">cur.limit(5); null;</tt> or on a query <tt class="docutils literal"><span class="pre">db.coll_1.find().limit(5);</span></tt>.</p>
<p>We can also get <strong>sorted</strong> results by appending <tt class="docutils literal">sort()</tt> method over the query. For e.g., on above cursor <tt class="docutils literal"><span class="pre">cur.sort({name:</span> <span class="pre">-1});</span> null;</tt> or on a query <tt class="docutils literal"><span class="pre">db.coll_1.find().sort({name:</span> <span class="pre">-1});</span></tt>. This will return documents reversely sorted by the value of <tt class="docutils literal">name</tt> field.</p>
<p>If we want to <strong>skip</strong> certain number of elements, <tt class="docutils literal">skip()</tt> method can be used. For e.g. on above cursor <tt class="docutils literal">cur.skip(5); null;</tt> or on a query <tt class="docutils literal"><span class="pre">db.coll_1.find().skip(5);</span></tt>. This will skip first 5 documents and then return the rest.</p>
<p>Sorting, skipping and limiting can be done at the same time e.g., <tt class="docutils literal"><span class="pre">db.coll_1.find().sort({score:</span> <span class="pre">-1}).skip(5).limit(10);</span></tt>.</p>
<p>All these three operation occur on the server-side in MongoDB.</p>
<p>If we want to count the number of documents we can get as a result for a query, simple append the method <tt class="docutils literal">count()</tt> at the end of the query.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.find({first_name:</span> <span class="pre">&quot;Joe&quot;}).count();</span></tt></p>
<p><strong>Wholesale updating of a document</strong></p>
<p><tt class="docutils literal">update</tt> method in MongoDB can actually do 4 different things. It takes atleast 2 arguments.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({name:</span> <span class="pre">&quot;Jon&quot;},</span> {name: &quot;Lola&quot;, job: <span class="pre">&quot;Engineer&quot;});</span></tt> will find a document with key <tt class="docutils literal">name: &quot;Jon&quot;</tt>, delete everything in it except <tt class="docutils literal">id</tt> field and then insert fields <tt class="docutils literal">name: &quot;Lola&quot;</tt> and <tt class="docutils literal">job: &quot;Engineer&quot;</tt> in it. This is a dangerous way of updating records since it deletes previous data.</p>
<p><strong>Using $set and $inc command</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({name:</span> <span class="pre">&quot;Jon&quot;},</span> {$set: {job: <span class="pre">&quot;Engineer&quot;}});</span></tt> will find a document with key <tt class="docutils literal">name: &quot;Jon&quot;</tt> and update just the <tt class="docutils literal">job</tt> field (or create if it doesn't exists) leaving rest of the data intact.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({name:</span> <span class="pre">&quot;Jon&quot;},</span> {$inc: {age: <span class="pre">1}});</span></tt> will find a document with key <tt class="docutils literal">name: &quot;Jon&quot;</tt> and increment just the <tt class="docutils literal">age</tt> field by 1 (or create if it doesn't exists) leaving rest of the data intact.</p>
<p>These are much safer way to update any field in a document.</p>
<p><strong>Using $unset command</strong></p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({name:</span> <span class="pre">&quot;Jon&quot;},</span> {$unset: {job: <span class="pre">1}});</span></tt> will find a document with key <tt class="docutils literal">name: &quot;Jon&quot;</tt> and remove just the <tt class="docutils literal">job</tt> field, leaving rest of the data intact.</p>
<p><strong>Manipulating arrays inside documents</strong></p>
<p>Suppose we have an object <tt class="docutils literal">{_id: 0, a: [1, 2, 3, 4]}</tt>. Following array manipulations can be done.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$set: {&quot;a.2&quot;: <span class="pre">5}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [1, 2, 5, 4]}</tt>. Changes <tt class="docutils literal">a[2]</tt> element to 5.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$push: {&quot;a&quot;: <span class="pre">5}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [1, 2, 5, 4, 6]}</tt>. Pushes value to the end of the array.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$pop: {&quot;a&quot;: <span class="pre">1}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [1, 2, 5, 4]}</tt>. Pops value out from the end of the array.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$pop: {&quot;a&quot;: <span class="pre">-1}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [2, 5, 4]}</tt>. Pops value from the beginning of the array.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$pushAll: {&quot;a&quot;: [7, 8, <span class="pre">9]}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [2, 5, 4, 7, 8, 9]}</tt>. Pushes all the values to the end of the array.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$pull: {&quot;a&quot;: <span class="pre">5}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [2, 4, 7, 8, 9]}</tt>. Deletes the specified value from the array, no matter the position.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$pullAll: {&quot;a&quot;: [2, 4, <span class="pre">8]}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [7, 9]}</tt>. Deletes all the specified values from the array, no matter the position.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({_id:0},</span> {$addToSet: {&quot;a&quot;: <span class="pre">5}});</span></tt> --&gt; <tt class="docutils literal">{_id: 0, a: [7, 9, 5]}</tt>. <tt class="docutils literal">addToSet</tt> treats array as a set and adds the value only if it is not already present.</p>
<p><strong>Upserts</strong></p>
<p>Suppose we want to update a document if it exists or if it doesn't exists, then create one with provided information.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({&quot;name&quot;:</span> <span class="pre">&quot;Elizabeth&quot;},</span> {$set: {destination: <span class="pre">&quot;Paris&quot;}});</span></tt></p>
<p>The query above will do nothing if there is no document with name field set to &quot;Elizabeth&quot;. However, <tt class="docutils literal">upsert</tt> flag can be set to true if we want a new collection to be created if it doesn't already exists.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({&quot;name&quot;:</span> <span class="pre">&quot;Elizabeth&quot;},</span> {$set: {destination: <span class="pre">&quot;Paris&quot;}},</span> {upsert: <span class="pre">true});</span></tt></p>
<p>The above query will create a new document <tt class="docutils literal">{name: &quot;Elizabeth&quot;, destination: &quot;Paris&quot;}</tt> if it didn't exist.</p>
<p><strong>Multi-update</strong></p>
<p>By default, all the update operation affects only one document. We can however set <tt class="docutils literal">multi</tt> flag to true if we want multiple documents to be updated.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.update({job:</span> <span class="pre">&quot;Doctor&quot;},</span> {$set: {title: <span class="pre">&quot;Dr&quot;}},</span> {multi: <span class="pre">true});</span></tt> will find <strong>all</strong> the documents having field <tt class="docutils literal">job: &quot;Doctor&quot;</tt> and set field <tt class="docutils literal">title: &quot;Dr&quot;</tt> in it.</p>
<p><strong>Removing data</strong></p>
<p><tt class="docutils literal"><span class="pre">db.people.remove({name:</span> <span class="pre">&quot;Comstock&quot;});</span></tt> removed all documents which had field <tt class="docutils literal">name: &quot;Comstock&quot;</tt> in it.</p>
<p>All documents in a collection can be removed by <tt class="docutils literal"><span class="pre">db.coll_1.remove();</span></tt> or a much faster way <tt class="docutils literal"><span class="pre">db.coll_1.drop();</span></tt>.</p>
<p><strong>getLastError</strong></p>
<p><tt class="docutils literal">getLastError</tt> is a very helpful command which can give information about the last query whether it failed or succeeded with a document containing the error message and other details such as whether existing documents were affected during an <tt class="docutils literal">update</tt> or not, how many documents were affected, etc.</p>
<p><tt class="docutils literal"><span class="pre">db.runCommand({getLastError:</span> <span class="pre">1});</span></tt></p>
</div>
<div class="section" id="indexes">
<h2>Indexes</h2>
<p>Indexed can be used to speed up the lookup operation in a collection. For example, if we have a collection with million of user's data and we use <tt class="docutils literal">username</tt> as primary key, an index on the collection can be generated by <tt class="docutils literal"><span class="pre">db.coll_1.ensureIndex({username:</span> <span class="pre">1});</span></tt>. The value indicates ascending order sorting while index creation.</p>
<p>Multiple keys can also be used to generate compound index. For example <tt class="docutils literal"><span class="pre">db.coll_1.ensureIndex({a:1,</span> b:1, <span class="pre">c:1});</span></tt>. Following are different combinations of queries and whether index is used for them -</p>
<ul class="simple">
<li><tt class="docutils literal">a, b</tt>, <tt class="docutils literal">a, b, c</tt> - Yes</li>
<li><tt class="docutils literal">a</tt> - Yes</li>
<li><tt class="docutils literal">b</tt>, <tt class="docutils literal">c</tt> - No</li>
<li><tt class="docutils literal">c, b</tt>, <tt class="docutils literal">b, a</tt> - No</li>
<li><tt class="docutils literal">a, c</tt> - Yes (only a part index is used)</li>
</ul>
<p>Don't generate index for every possible type of query you might make. Instead just create index for most common type of queries. Indexes are not costless, as they take up more memory space and have to be additionally updates everytime something is changed.</p>
<p>All the present indexes in a database can be looked up using <tt class="docutils literal">db.system.indexes.find()</tt>. All the present indexes in a collection can be looked up with <tt class="docutils literal">db.coll_1.getIndexes()</tt>.</p>
<p>Index can be dropped with <tt class="docutils literal"><span class="pre">db.dropIndex({username:</span> <span class="pre">1});</span></tt>.</p>
<p><strong>Multikey Index</strong></p>
<p>If we want to make an index for a key which contains array values, then MongoDB makes indexe for each of the value in the array which is called Multikey index. However, a multikey compound index with two or more parallel arrays cannot be created.</p>
<p><strong>Unique Index</strong></p>
<p>The key in an index can be forced to be unique so that none of the values for the index keys are repeated. It can be done by providing a second argument while creating the index. For example, <tt class="docutils literal">_id</tt> key index is a unique one.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.ensureIndex({username:1},</span> {unique: <span class="pre">true});</span></tt></p>
<p>If we want to create a unique index on a collection but it already has some duplicates, then we can remove the duplicates while creating index. Remember that this is dangerous since you can't control which documents are deleted.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.ensureIndex({username:</span> 1}, {unique: true, dropDups: <span class="pre">true});</span></tt></p>
<p><strong>Sparse Index</strong></p>
<p>If we want to create a unique index with a key on a collection but not all the documents in the collection have that key then it would create a problem.</p>
<p>For e.g., <tt class="docutils literal">{a: 1, b:2, c: 3}, {a: 4, b: 5}, {a: 6, b: 7}</tt> are the three documents in a collection. If we want to create a unique index for key <tt class="docutils literal">c</tt> but last two documents don't have it and MongoDB by default assume them to have <tt class="docutils literal">c: null</tt> value. Now, since both of them have <tt class="docutils literal">c: null</tt> value, it would be considered as duplicate and thus, unique index can't be created on them.</p>
<p>Sparse Index can solve the problem. <tt class="docutils literal"><span class="pre">db.coll_1.ensureIndex({username:</span> 1}, {unique: true, sparse: <span class="pre">true});</span></tt></p>
<p>This index will include only the documents which have the <tt class="docutils literal">username</tt> key set to some value.</p>
<p>However, Sparse Index can create some weird artifact with some queries, especially with sort. For e.g. <tt class="docutils literal"><span class="pre">db.coll_1.find().sort({username:</span> <span class="pre">1});</span></tt> should include all the documents in the collection but the actual result will include only the ones in the index. Queries in MongoDB always try to use an index when present, so here the sort part of the query uses the sparse index which results in incorrect output.</p>
<p><strong>Background Index Creation</strong></p>
<p>By default, indexes are created in foreground which is faster but it blocks all the other writers. But if it is essential to prevent the blockage of the other writers such as in production environment, then background creation can be preffered which doesn't blocks other writers but it a bit slower. Background creation can be done via providing <tt class="docutils literal">background:1</tt> in the second argument.</p>
<p><strong>Using Explain</strong></p>
<p>We can find out whether the queries we perform use an index or not. Appending <tt class="docutils literal">explain()</tt> method on the end of a query gives us information about whether index was used or not, which index was used, how many objects were scanned, how many results are there, how many seconds it took, etc.</p>
<p><em>Choosing an Index*</em></p>
<p>If there are multiple indexes for a key, then MongoDB has to decide which one to use (only one can be used for a query). What it does is that it runs benchmark for all the indexes internally and uses the one which took least amount of time.</p>
<p><strong>Collection and Index Stats</strong></p>
<p><tt class="docutils literal">db.coll_1.stats()</tt> can be used to get the statistics of collection which includes the total collection size, average document size, total index size and individual index sizes.</p>
<p><tt class="docutils literal">db.coll_1.totalIndexSize()</tt> can be used to get the total index size for a collection.</p>
<p><strong>Hinting an Index</strong></p>
<p>We can manually specify which index to use by appending <tt class="docutils literal">hint()</tt> method to the query. For e.g., <tt class="docutils literal"><span class="pre">db.coll_1.hint({username:</span> <span class="pre">1});</span></tt> or if we want no index to be used for the query, then <tt class="docutils literal"><span class="pre">db.coll_1.hint({$natural:</span> <span class="pre">1});</span></tt></p>
<p><strong>Profiling</strong></p>
<p>There are 3 levels of logging-</p>
<ul class="simple">
<li>1 - Off</li>
<li>2 - Log slow queries</li>
<li>3 - Log all queries</li>
</ul>
<p>By default, all the queries that take more than 1000ms are logged into the <tt class="docutils literal">mongod</tt> instance's log. This value can be changed to, for e.g. 2ms by running <tt class="docutils literal">$ mongod <span class="pre">--profile</span> 1 <span class="pre">--slowms</span> 2</tt>.</p>
<p>Logs can be checked using <tt class="docutils literal"><span class="pre">db.systems.profile.find();</span></tt>.</p>
<p>Logs for specific collections cab be done like this - <tt class="docutils literal"><span class="pre">db.systems.profile.find({ns:</span> <span class="pre">/dbName.collName/}).sort(ts:</span> 1);</tt>. This query will find logs for collName collection in dbName database and sort it by timestamp.</p>
<p>Current profiling level can be checked using <tt class="docutils literal"><span class="pre">db.getProfilingLevel();</span></tt> and status using <tt class="docutils literal">db.getProfilingStatus</tt>.</p>
<p>Profiling status can be set using <tt class="docutils literal">db.setProfilingLevel(2, 10)</tt>. This will change profiling level to 1 and log queries that take more than 10ms.</p>
<p><strong>mongotop and mongostat</strong></p>
<p>Similar to unix's top program which give high level view and gives info about which collection are taking how much resource. mongotop takes one argument which is the time interval to refresh the data in seconds.</p>
<p>mongostat is similar to unix's iostat command. It shows all the different type of operations happening, database size, number of connection. One of the interesting thing it shows is <tt class="docutils literal">idx miss %</tt> which tells the % of queries where the index was used but it has to hit the disk since there wasn't enough memory to accomodate the index.</p>
</div>
<div class="section" id="aggregation">
<h2>Aggregation</h2>
<p>Example of an aggregation query -</p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: &quot;$manufacturer&quot;, num_products: {$sum: 1} } } ] );</tt></p>
<p>Here, the aggregate method takes an array as the argument. It contains different aggregation queries. Here we group by manyfacturer name and then sum the number of products. The value to <tt class="docutils literal">$group</tt> key is the schema for the result. The result will contain <tt class="docutils literal">_id</tt> field with the manufacturer's name and <tt class="docutils literal">num_products</tt> field with number of respective total products. For every product in a group, it will add 1 (which we specified) to the <tt class="docutils literal">num_products</tt> field.</p>
<p>There are various stages for any aggregation query and results can be pipelined through these stages -</p>
<ul class="simple">
<li>$project</li>
<li>$match</li>
<li>$group</li>
<li>$sort</li>
<li>$skip</li>
<li>$limit</li>
<li>$unwind</li>
</ul>
<p><strong>Compound Grouping</strong></p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: {manufacturer: &quot;$manufacturer&quot;, category: <span class="pre">&quot;$category&quot;},</span> num_products: {$sum: 1} } } ] );</tt></p>
<p><strong>Aggregation Expression Overview</strong></p>
<ul class="simple">
<li>$sum</li>
<li>$avg</li>
<li>$min</li>
<li>$max</li>
<li>$push</li>
<li>$addtoSet</li>
<li>$first</li>
<li>$last</li>
</ul>
<p><strong>Using $sum</strong></p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: &quot;$manufacturer&quot;, sum_prices: {$sum: &quot;$price&quot;} } } ] );</tt></p>
<p>Here, for every product in the group, its <tt class="docutils literal">price</tt> field is added to the resulting document's <tt class="docutils literal">sum_prices</tt> field. So, the <tt class="docutils literal">sum_prices</tt> field will contain the total price for products for every manufacturer.</p>
<p><strong>Using $avg</strong></p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: &quot;$category&quot;, avg_price: {$avg: &quot;$price&quot;} } } ] );</tt></p>
<p>This will show the average price for each category.</p>
<p><strong>Using $addToSet</strong></p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: &quot;$manufacturer&quot;, categories: {$addToSet: &quot;$category&quot;} } } ] );</tt></p>
<p>The resulting document will contain keys named <tt class="docutils literal">categories</tt> which will contain the name of the categories (in a set (array with unique elements)) for the corresponding manufacturer.</p>
<p><strong>Using $push</strong></p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: &quot;$manufacturer&quot;, categories: {$push: &quot;$category&quot;} } } ] );</tt></p>
<p>Similar to <tt class="docutils literal">%addToSet</tt> but doesn't makes a set with unique items, rather makes a normal array which might contain duplicates.</p>
<p><strong>Using $max and $min</strong></p>
<p><tt class="docutils literal">db.products.aggregate( [ { $group: { _id: &quot;$manufacturer&quot;, max_price: {$max: &quot;$price&quot;} } } ] );</tt></p>
<p>Finds the maximum price for the product by the manufacturers.</p>
<p><strong>Double $group stages</strong></p>
<p><tt class="docutils literal">db.grades.aggregate([ {$group: {_id: {class_id: &quot;$class_id&quot;, student_id: <span class="pre">&quot;$student_id&quot;},</span> average: {$avg: <span class="pre">&quot;$score&quot;}}},</span> {$group: {_id: &quot;$_id.class_id&quot;, average: {$avg: <span class="pre">&quot;$average&quot;}}}</span> ]);</tt></p>
<p>This will pipe the result from first aggregation to the second one.</p>
<p><strong>$project</strong></p>
<p><tt class="docutils literal">$project</tt> is used for reshaping/projecting the document as they come through the pipeline. Its a 1:1 stage of the pipeline, same number of document leave the <tt class="docutils literal">$project</tt> phase which come in. It can -</p>
<ul>
<li><p class="first">remove keys</p>
</li>
<li><p class="first">add new keys</p>
</li>
<li><p class="first">reshape keys</p>
</li>
<li><dl class="first docutils">
<dt>use some simple functions on keys</dt>
<dd><ul class="first last simple">
<li>$toUpper</li>
<li>$toLower</li>
<li>$add</li>
<li>$multiply</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">products</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">([{</span>
    <span class="nx">$project</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">_id</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">maker</span><span class="o">:</span> <span class="p">{</span><span class="nx">$toLower</span><span class="o">:</span> <span class="s2">&quot;$manufacturer&quot;</span><span class="p">},</span> <span class="c1">// manufacturer name to lowercase</span>
        <span class="nx">details</span><span class="o">:</span> <span class="p">{</span><span class="nx">category</span><span class="o">:</span> <span class="s2">&quot;$category&quot;</span><span class="p">,</span>
                  <span class="nx">price</span><span class="o">:</span> <span class="p">{</span><span class="nx">$multiply</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;$price&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">]}}</span> <span class="c1">// 10 x&#39;es the price</span>
        <span class="p">},</span>
        <span class="nx">item</span><span class="o">:</span> <span class="s2">&quot;$name&quot;</span>
<span class="p">}]);</span>
</pre></div>
<p><strong>$match</strong></p>
<p>It acts as a filter for the incoming documents. E.g. -</p>
<!-- code-block::javascript

db.zips.aggregate([
    {$match: {state: "NY"}}, //filter and pipe only NY state documents
    {$group: {
        _id: "$city",
        population: {$sum: "$pop"}, // sums the population
        zip_codes: {$addToSet: "$_id"} // creates set of zip codes
    }}
]); -->
<p><strong>$sort</strong></p>
<p><tt class="docutils literal">$sort</tt> operation happens inside the memory.</p>
<!-- code-block::javascript

db.zips.aggregate([
    {$match: {state: "NY"}}, //filter and pipe only NY state documents
    {$group: {
        _id: "$city",
        population: {$sum: "$pop"}, // sums the population
        zip_codes: {$addToSet: "$_id"} // creates set of zip codes
    }},
    {$sort: {
        population: -1 // sorts the result in descending order of population
    }}
]); -->
<p><strong>$limit and $skip</strong></p>
<p>Very similar to how how sort, skip and limit work with <tt class="docutils literal">find</tt> method queries.</p>
<!-- code-block::javascript

db.zips.aggregate([
    {$match: {state: "NY"}}, //filter and pipe only NY state documents
    {$sort: {
        pop: -1 // sorts the result in descending order of population
    }},
    {$skip: 10}, // skips first 10 documents
    {$limit: 5} // limits to only 5 results
]); -->
<p><strong>$first and $last</strong></p>
<p>As the names suggest, these will help get the the first and the last documents. E.g., if we want to find the largest city in each state -</p>
<div class="highlight"><pre><span class="nx">db</span><span class="p">.</span><span class="nx">zips</span><span class="p">.</span><span class="nx">aggregate</span><span class="p">([</span>
    <span class="p">{</span><span class="nx">$group</span><span class="o">:</span> <span class="p">{</span><span class="nx">_id</span><span class="o">:</span> <span class="p">{</span><span class="nx">state</span><span class="o">:</span> <span class="s2">&quot;$state&quot;</span><span class="p">,</span> <span class="nx">city</span><span class="o">:</span> <span class="s2">&quot;$city&quot;</span><span class="p">},</span> <span class="nx">population</span><span class="o">:</span> <span class="p">{</span><span class="nx">$sum</span><span class="o">:</span> <span class="nx">pop</span><span class="p">}}},</span>
    <span class="p">{</span><span class="nx">$sort</span><span class="o">:</span> <span class="p">{</span><span class="s2">&quot;_id.state&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">population</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}},</span>
    <span class="c1">// since the document was sorted by descending order of population, highest population city is at the top</span>
    <span class="p">{</span><span class="nx">$group</span><span class="o">:</span> <span class="p">{</span><span class="nx">_id</span><span class="o">:</span> <span class="s2">&quot;_id.state&quot;</span><span class="p">,</span> <span class="nx">city</span> <span class="p">{</span><span class="nx">$first</span><span class="o">:</span> <span class="s2">&quot;$_id.city&quot;</span><span class="p">}}}</span> <span class="c1">// get the top/first city</span>
<span class="p">]);</span>
</pre></div>
<p><strong>$unwind</strong></p>
<p>Unwind can be used to unwind an array inside the document. After an unwind operation on a key containing array, new documents are formed with the remainder of the document and each elements from the array.</p>
<p><tt class="docutils literal"><span class="pre">db.coll_1.aggregate([{$unwind:</span> <span class="pre">$b}]);</span></tt></p>
<p><tt class="docutils literal">{a: 1, b: [2, 3]}</tt> will get unwinded to <tt class="docutils literal">{a:1, b:2}</tt> and <tt class="docutils literal">{a:1, b:3}</tt>.</p>
<p><strong>Limitations of the Aggregation Framework</strong></p>
<ul class="simple">
<li>Result document limited to 16MB of memory</li>
<li>Limited to use only 10% of the memory of the machine</li>
<li>In a sharded environment, any aggregation query is brought back to <tt class="docutils literal">mongos</tt> instance after the first grouping by a <tt class="docutils literal">mongod</tt> instance which might affect performance on the machine running <tt class="docutils literal">mongos</tt> if the data set is huge.</li>
</ul>
<p>Alternatives to the aggregation framework - mapreduce, hadoop.</p>
</div>
<div class="section" id="application-engineering">
<h2>Application Engineering</h2>
<p><strong>Write Concern</strong></p>
<p>In the mongo shell, every time a query is made, the shell calls the <tt class="docutils literal">getLastError</tt> method to see if it succeeded or failed. But while using drivers such as PyMongo, this is not the default behavior. We have to set the safe mode values to make the driver check if there was any error. It takes two parameter - w and j. Following are the different cases -</p>
<ul class="simple">
<li>w 0, j 0 - fire and forget, doesn't checks for errors</li>
<li>w 1, j 0 - acknowledge that the query was received but doesn't checks if it succeeded (default for the drivers)</li>
<li>w 1, j 1 - commit to journal, means that query was received, there is no error and it is fault tolerant in case of power loss since the query stored in the journal can be used for recovery (recommended)</li>
</ul>
<p><strong>Network Error</strong></p>
<p>If the application sends the query to mongod over the network then there is a possibility of uncertainity whether the query was completed or not due to network error. For e.g., if the query was made, mongod received it but then suddenly the network went down. The mongod may have executed the query and but the application didn't receive any acknowledgement so it has no idea whether the query succeeded or not. Thogu application can later the database to see if the change was made or not but still there is a certain level of uncertainity.</p>
<p><strong>Replication</strong></p>
<p>To maintain availability and fault tolerance in case of downtime of a mongod server, replica sets are used. They mirror the same data and synchronize it asynchronously. At least 3 mongod servers are required in a replica set. One of them is primary to which the application or mongos talks and rest are secondary. If the primary one goes down, then election is done by the rest and one is chosen are primary. When the ex-primary server comes back up, it joins the set as a secondary server.</p>
<p>Type of Replica Set Nodes -</p>
<ul class="simple">
<li>Regular - Normal ones which can take place of the primary one if it goes down</li>
<li>Arbiter - Just present for voting purposes.</li>
<li>Delayed/Regular - Is usually a few hours behind the primary node and is present for disaster recovery. It cannot participate in voting and cannot become a primary node.</li>
<li>Hidden - Used for different purposes, e.g. analytics. It cannot become the primary node but can participate in the voting.</li>
</ul>
<p><strong>Write Consistency</strong></p>
<p>For a strong consistency between read and writes, it is recommended to read from and write to only the primary node. Though it is possible to do read operation from secondary nodes (by running <tt class="docutils literal"><span class="pre">rs.slaveOk();</span></tt> on them) but there is a chance that you might get stale data if the synchonization didn't occur fast enough.</p>
<p><strong>Create Replica Set</strong></p>
<p>Here for the sake of example, we will make the replicas sets using the following command on our single machine-</p>
<div class="highlight"><pre>mkdir -p /data/rs1 /data/rs2 /data/rs3
mongod --replSet rs1 --logpath <span class="s2">&quot;1.log&quot;</span> --dbpath /data/rs1 --port 27017 --fork
mongod --replSet rs1 --logpath <span class="s2">&quot;2.log&quot;</span> --dbpath /data/rs2 --port 27018 --fork
mongod --replSet rs1 --logpath <span class="s2">&quot;3.log&quot;</span> --dbpath /data/rs3 --port 27019 --fork
</pre></div>
<p><tt class="docutils literal"><span class="pre">--replSet</span> rs1</tt> makes sure that all the three instances belong to same replica set and <tt class="docutils literal"><span class="pre">--fork</span></tt> makes it run in the background so that 3 different shells are not required. At this point, all 3 instances do not know about each other.</p>
<p>Now we need to create a configuration to make sure that they work in co-operation.</p>
<div class="highlight"><pre><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_id</span><span class="o">:</span> <span class="s2">&quot;rs1&quot;</span><span class="p">,</span> <span class="c1">// replSet we used to run the instances</span>
    <span class="nx">members</span><span class="o">:</span> <span class="p">[</span>
        <span class="c1">// We don&#39;t want host 0 to be the primary node, so setting priority 0</span>
        <span class="c1">// And we are delaying it by 5 seconds.</span>
        <span class="p">{</span><span class="nx">_id</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">host</span><span class="o">:</span> <span class="s2">&quot;vivekagr.local: 27017&quot;</span><span class="p">,</span> <span class="nx">priority</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">slaveDelay</span><span class="o">:</span> <span class="mi">5</span><span class="p">},</span>
        <span class="p">{</span><span class="nx">_id</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">host</span><span class="o">:</span> <span class="s2">&quot;vivekagr.local: 27017&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="nx">_id</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">host</span><span class="o">:</span> <span class="s2">&quot;vivekagr.local: 27019&quot;</span><span class="p">},</span>
    <span class="p">]</span>
<span class="p">};</span>
<span class="nx">rs</span><span class="p">.</span><span class="nx">initiate</span><span class="p">(</span><span class="nx">config</span><span class="p">);</span>
<span class="nx">rs</span><span class="p">.</span><span class="nx">status</span><span class="p">();</span>
</pre></div>
<p>We need to open mongo shell and connect to either port 27018 or 27019 and not 27017 since we can't run the configuration step on a node that cannot become a primary node.</p>
<p>Replication internally works by using a capped collection <tt class="docutils literal">oplog.rs</tt> in <tt class="docutils literal">local</tt> database. Secondary nodes query primary to check if any new data has been added to the <tt class="docutils literal">oplog.rs</tt> and then it is synchronized.</p>
<p><strong>Failover and Rollback</strong></p>
<p>Suppose if the secondary nodes are lagging few seconds behind the primary node and suddenly primary node goes offline then one of the secondary servers will be promoted to primary position but it won't have the writes for last few seconds. Now, when the ex-primary node comes online and while synchronizing data, it sees that it has writes which were not synchronized with other nodes, it will rollback that data and write it to a rollback log.</p>
<p>If an application is writing or reading data during a failover and election situation, exception will occur so it necessary to catch such exception and handle the situation accordingly.</p>
<p><strong>Revisiting Write Concern</strong></p>
<p>Suppose we have 3 nodes in total - 1 primary and 2 secondary. Now consider the following vaues of w and j.</p>
<ul class="simple">
<li><tt class="docutils literal">w = 1</tt> - wait for just nodes (primary) to acknowledge the write</li>
<li><tt class="docutils literal">w = 2</tt> - wait for two nodes (primary &amp; one secondary) to acknowledge the write</li>
<li><tt class="docutils literal">w = 3</tt> - wait for three nodes (all) to acknowledge the write</li>
<li><tt class="docutils literal">j = 1</tt> - wait for only primary to write it all the way down to disk and journal</li>
</ul>
<p><tt class="docutils literal">wtimeout</tt> refers to the maximum time to wait.</p>
<p>These values can be set in either of the three ways - while configuring the replica set, while making connection to the mongod or inside the collection itself.</p>
<p><tt class="docutils literal">w: majority</tt> can also be set and is considered to be the best practice. It avoids having the data rolled back in case of a single node failure. Take the three node example. If you set w:majority, then at least one other node will have the date at the time of failover. That node will be preferred to take over as primary. The node that is furthest ahead will be preferred in the election of a new primary.</p>
<p><strong>Read Preferences</strong></p>
<p>There are various read preferences that can be set -</p>
<ul class="simple">
<li>primary</li>
<li>secondary</li>
<li>secondary preferred</li>
<li>primary preferred</li>
<li>nearest</li>
<li>tagging</li>
</ul>
</div>
<div class="section" id="sharding">
<h2>Sharding</h2>
<p>To get horizontal scalability, we break up the database on to multiple logical hosts and that is done according to a shard key. Shard key is some part of the document itself (usually a unique key for the collection). There has to be an index present beforehand for the key which is going to be used as the shard key.</p>
<p><strong>Building a Sharding Environment</strong></p>
<p>See <tt class="docutils literal">init_sharded_env.sh</tt> file for the process and code.</p>
<p><strong>Implications of sharding on development</strong></p>
<ul class="simple">
<li>Every query should include a shard key</li>
<li>Shard key is immutable</li>
<li>Index that starts with the shard key is required</li>
<li>For update commands, eithe rshard key has to be provided or multi key set to true (which results in the broadcast of the query to all the nodes)</li>
<li>No shard key in query means that query is broadcasted to all nodes which is inefficient</li>
<li>No unique key unless part of the shard key because mongos has no way of knowing that whether the copy exists on other shards since each shard has its own set of unique keys</li>
</ul>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[S3 - Basics of Architecture, Machine Code]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s3.html"/>
        <published>2013-05-04T00:00:00+05:30</published>
        <updated>2013-05-13T04:52:17+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s3.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>Translation Impacts Performance</p>
<p>The time required to execute a program depends on:</p>
<ul class="simple">
<li>The program (as written in C, for instance)</li>
<li>The compiler: what set of assebler it translates the C program into</li>
<li>The Instruction Set Architecture (ISA): what set of instructions it makes available to the compiler</li>
<li>The hardware implementation: how much time it takes to execute an instruction</li>
</ul>
<p>ISA (Instruction Set): The parts of processor one needs to understand to write assembly code. (What is directly visible to the software)</p>
<p>The ISA defines:</p>
<ul class="simple">
<li>The system's state (e.g. registers, memory, program counter)</li>
<li>The instructions that CPU can execute</li>
<li>The effect that each of these instructions will have on the system state</li>
</ul>
<p>General ISA Design Decisions:</p>
<ul>
<li><dl class="first docutils">
<dt>Instructions</dt>
<dd><ul class="first last simple">
<li>What instructions are available? What do they do?</li>
<li>How are they encoded?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Registers</dt>
<dd><ul class="first last simple">
<li>How many registers are there?</li>
<li>How wide are they?</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Memory</dt>
<dd><ul class="first last simple">
<li>How do you specify a memory location?</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="section" id="x86">
<h2>x86</h2>
<p>x86 is one type of ISA. Processors that implement the x86 ISA completely dominate the server, desktop and laptop markets.</p>
<p>Evolutionary design</p>
<ul class="simple">
<li>Backwards compatible up until Intel 8086, introduced in 1978</li>
<li>Added more features as time goes on</li>
</ul>
<p>x86 can be defined as Complex Instruction Set Computer (CISC)</p>
<ul class="simple">
<li>Many different instructions with many different formats but only small subset is encountered with Linux programs</li>
<li>(as opposed to Reduced Instructions Set Computers (RISC) which use simpler instructions)</li>
</ul>
<p>Intel and AMD both develop x86 and x86-64 processors with different hardware implementations underneath. But since the ISA (which is an abstraction) remains the same i.e. x86, same programs can run on both of them.</p>
</div>
<div class="section" id="assembly-programmer-s-view">
<h2>Assembly Programmer's View</h2>
<p>Programmer-Visible State</p>
<ul>
<li><dl class="first docutils">
<dt>PC: Program Counter</dt>
<dd><ul class="first last simple">
<li>Address of the next instructions</li>
<li>Called &quot;EIP&quot; (IA32) or &quot;RIP&quot; (x86-64)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Register file</dt>
<dd><ul class="first last simple">
<li>Heavily used program data</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Condition codes</dt>
<dd><ul class="first last simple">
<li>Store status information about most recent arithmetic operation</li>
<li>Used for conditional branching</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Memory</dt>
<dd><ul class="first last simple">
<li>Byte addressable memory</li>
<li>Code, user data, (some) OS data</li>
<li>Includes stack used to support procedures</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="assembly">
<h2>Assembly</h2>
<p>Three basic kinds of Instructions</p>
<ul>
<li><p class="first">Perform arithmetic function on register or memory data</p>
</li>
<li><dl class="first docutils">
<dt>Transfer data between memory and register</dt>
<dd><ul class="first last simple">
<li>Load data from memory into register'</li>
<li>Store register data into memory</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Transfer control</dt>
<dd><ul class="first last simple">
<li>Unconditional jumps to/from procedures</li>
<li>Conditional branches</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Data Types</p>
<ul>
<li><dl class="first docutils">
<dt>&quot;Integer&quot; data of 1, 2, 4 (IA32), or 8 (just in x86-64) bytes. Can be:</dt>
<dd><ul class="first last simple">
<li>Data values</li>
<li>Addresses (untyped pointers)</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">Floating point data of 4, 8, or 10 bytes</p>
</li>
<li><p class="first">No aggregate types such as arrays or structs, just contiguosly allocated bytes in memory</p>
</li>
</ul>
<p>Turning C into Object Code</p>
<ul>
<li><p class="first">Code in files p1.c p2.c</p>
</li>
<li><dl class="first docutils">
<dt>Compile using command <tt class="docutils literal">gcc <span class="pre">-01</span> p1.c p2.c <span class="pre">-o</span> p</tt></dt>
<dd><ul class="first last simple">
<li>Use basic optimizations (-01)</li>
<li>Put result binary in file p</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Pathway</p>
<ul class="simple">
<li>text <tt class="docutils literal">C program (p1.c p2.c)</tt> -- Compiler (<tt class="docutils literal">gcc <span class="pre">-S</span></tt>) --</li>
<li>--&gt; text <tt class="docutils literal">Asm program (p1.s p2.s)</tt> -- Assembler (gcc or as) --</li>
<li>--&gt; binary <tt class="docutils literal">Object program (p1.o p2.o)</tt> -- Linker (gcc or ld) --</li>
<li>--&gt; binary <tt class="docutils literal">Executable program (p)</tt> &lt;--- Static libraries (.a)</li>
</ul>
<p>Assembler</p>
<ul class="simple">
<li>Translates <tt class="docutils literal">.s</tt> into <tt class="docutils literal">.o</tt></li>
<li>Binary encoding of each instruction</li>
<li>Near complete image of executable code</li>
<li>Missing links between code in different files</li>
</ul>
<p>Linker</p>
<ul class="simple">
<li>Resolves references between object files and (re)locates theie data</li>
<li>Combines with static run-time libraries, e.g. code for <tt class="docutils literal">malloc</tt>, <tt class="docutils literal">printf</tt></li>
<li>Some libraries are dynamically linked. Linking occurs when program begins execution</li>
</ul>
</div>
<div class="section" id="disassemblers">
<h2>Disassemblers</h2>
<p><tt class="docutils literal">objdump <span class="pre">-d</span> &lt;file&gt;</tt></p>
<ul class="simple">
<li>Useful tool for examining object code</li>
<li>Analyzes bit pattern series of instructions (delineates instructions)</li>
<li>Produces near-exact rendition of assembly code</li>
<li>Can be run either on the executable or .o files (object code).</li>
</ul>
<p>Alternatively, gdb debugger can also be used for disassembly.</p>
</div>
<div class="section" id="registers">
<h2>Registers</h2>
<p><strong>What is Register?</strong></p>
<ul class="simple">
<li>A location in the CPU that stores a small amount of data which can be accessed very quickly (once every clock cycle)</li>
<li>Registers are at the heart of assembly programming. They are precious commodity in all architectures but especially x86</li>
</ul>
<p>IA32 has 8 different registers of size 32 bits each. Two of them are special purpose (stack pointer and base pointer).</p>
<p>x86-64 has 16 registers each of size 64 bits (also backward compatible as 8, 16, 32 bits). They happen to be the superset of the previous architectures so they are backward compatible. Only one is for special purpose.</p>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[S4 - x86 Assembly]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s4.html"/>
        <published>2013-05-04T00:00:00+05:30</published>
        <updated>2013-05-13T04:55:19+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s4.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>Moving Data</p>
<ul class="simple">
<li><tt class="docutils literal">movx &lt;source&gt; &lt;dest&gt;</tt></li>
<li>x is one of {b, w, l}</li>
<li>movl &lt;source&gt; &lt;dest&gt; - Move 4-byte &quot;long word&quot;</li>
<li>movw &lt;source&gt; &lt;dest&gt; - Move 2-byte &quot;word&quot;</li>
<li>movb &lt;source&gt; &lt;dest&gt; - Move 1-byte &quot;byte&quot;</li>
<li>movq &lt;source&gt; &lt;dest&gt; - Move 8-byte &quot;quad word&quot; (only in x86-64)</li>
</ul>
<p>&lt;source&gt; and &lt;dest&gt; are operands. There are 3 types of operands:</p>
<ul>
<li><dl class="first docutils">
<dt>Immediate: Constant integer data</dt>
<dd><ul class="first last simple">
<li>E.g. <tt class="docutils literal">$x400</tt>, <tt class="docutils literal"><span class="pre">$-533</span></tt></li>
<li>Like C constant, but prefixed with <tt class="docutils literal">$</tt></li>
<li>Encoded with 1,2 or 4 bytes</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Register: One of 8 integer registers</dt>
<dd><ul class="first last simple">
<li>E.g. <tt class="docutils literal">%eax</tt>, <tt class="docutils literal">%edx</tt></li>
<li>But <tt class="docutils literal">%esp</tt> and <tt class="docutils literal">%ebp</tt> are reserved for special use</li>
<li>Others have special uses for particular instructions</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Memory: 4 consecutive bytes of memory at address given by register</dt>
<dd><ul class="first last simple">
<li>Simplest example: (%eax) (this means store the data in the memory address that is stored in %eax register)</li>
<li>Various other &quot;address modes&quot;</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="section" id="movl-operand-combinations">
<h2>movl Operand Combinations</h2>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="13%" />
<col width="40%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Source</th>
<th class="head">Dest</th>
<th class="head">Source, Dest</th>
<th class="head">C Analog</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Imm</td>
<td>Reg</td>
<td><tt class="docutils literal">movl $0x4, %eax</tt></td>
<td><tt class="docutils literal">var a = 0x4</tt></td>
</tr>
<tr><td>Imm</td>
<td>Mem</td>
<td><tt class="docutils literal">movl <span class="pre">$-147,</span> (%eax)</tt></td>
<td><tt class="docutils literal">*p_a = <span class="pre">-147</span></tt></td>
</tr>
<tr><td>Reg</td>
<td>Reg</td>
<td><tt class="docutils literal">movl %eax, %edx</tt></td>
<td><tt class="docutils literal">var_d = var_a</tt></td>
</tr>
<tr><td>Reg</td>
<td>Mem</td>
<td><tt class="docutils literal">movl %eax, (%edx)</tt></td>
<td><tt class="docutils literal">*p_d = var_a</tt></td>
</tr>
<tr><td>Mem</td>
<td>Reg</td>
<td><tt class="docutils literal">movl (%eax), %edx</tt></td>
<td><tt class="docutils literal">var_d = *p_a</tt></td>
</tr>
</tbody>
</table>
<p>Cannot do memory-memory transfer with a single instruction.</p>
</div>
<div class="section" id="memory-addressing-modes">
<h2>Memory Addressing Modes</h2>
<p>Indirect: (R) refers to Mem[Reg[R]] where register R specifies a memory address</p>
<p>E.g.: <tt class="docutils literal">movl (%ecx), %eax</tt></p>
<p>Displacement: D(R) refers to Mem[Reg[R]+D] where R specifies a memory address (e.g. the start of some memory region). Constant displacement D specifies the offset from that address.</p>
<p>E.g.: <tt class="docutils literal">movl <span class="pre">8(%ebp),</span> %edx</tt> psuedo-equivalent to %edx = Mem[%ebp + 8]</p>
<p>Watch <tt class="docutils literal">5 - 1 - Moving Data <span class="pre">(1738).mp4</span></tt> for an assembly program example.</p>
<p>Watch <tt class="docutils literal">5 - 3 - Memory Addressing Modes <span class="pre">(1422).mp4</span></tt>.</p>
</div>
<div class="section" id="conditionals-and-control-flow">
<h2>Conditionals and Control Flow</h2>
<ul>
<li><dl class="first docutils">
<dt>A condition branch is sufficient to implement most control flow structs offered in high level languages like</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">if (condition) then <span class="pre">{...}</span> else <span class="pre">{...}</span></tt></li>
<li><tt class="docutils literal">while (condition) <span class="pre">{...}</span></tt></li>
<li><tt class="docutils literal">do <span class="pre">{...}</span> while (condition)</tt></li>
<li><tt class="docutils literal">for (initialization; condition; iterative) <span class="pre">{...}</span></tt></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Unconditional branches implement some related control flow constructs</dt>
<dd><ul class="first last simple">
<li>break, continue</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">In x86, we'll refer to branches as &quot;jumps&quot; (either conditional or unconditional)</p>
</li>
</ul>
<p>Jumping: <tt class="docutils literal">jX</tt> is used to jump to different part of the code depending on the condition codes such as <tt class="docutils literal">jmp</tt> for unconditional, <tt class="docutils literal">je</tt> for equal/zero, etc.</p>
<p>When a branch instruction is executed, value of instruction pointer <tt class="docutils literal">%eip</tt> is changed to one of the various condition codes:</p>
<ul class="simple">
<li><tt class="docutils literal">CF</tt> Carry Flag (for unsigned)</li>
<li><tt class="docutils literal">ZF</tt> Zero Flag</li>
<li><tt class="docutils literal">SF</tt> Sign Flag (for signed)</li>
<li><tt class="docutils literal">OF</tt> Overflow Flag (for signed)</li>
</ul>
<p>These condition codes can be set <strong>implicitly</strong> as a side-effect of arithmetic operations such as <tt class="docutils literal">addl &lt;source&gt; &lt;destination&gt;</tt> &lt;--&gt; <tt class="docutils literal">t = a+b</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">CF</tt> set if carry out from MSB (unsigned overflow)</li>
<li><tt class="docutils literal">ZF</tt> set if <tt class="docutils literal">t == 0</tt></li>
<li><tt class="docutils literal">SF</tt> set if <tt class="docutils literal">t &lt; 0</tt> (as signed)</li>
<li><tt class="docutils literal">OF</tt> set if two's complement (signed) overflow</li>
</ul>
<p>Also, these condition codes can be set <strong>explicitly</strong> using &quot;compare&quot; (<tt class="docutils literal">cmpl/cmpq</tt>) instruction such as <tt class="docutils literal">cmpl b, a</tt> &lt;--&gt; <tt class="docutils literal">a - b</tt>. Here, there result is not directly stored anywhere, rather the condition code is determined by the result and that is stored in instruction pointer.</p>
<ul class="simple">
<li><tt class="docutils literal">CF</tt> set if carry out from MSB (unsigned overflow)</li>
<li><tt class="docutils literal">ZF</tt> set if <tt class="docutils literal">a == b</tt> (essentially same as <tt class="docutils literal">a - b == 0</tt>)</li>
<li><tt class="docutils literal">SF</tt> set if <tt class="docutils literal"><span class="pre">(a-b)</span> &lt; 0</tt> (as signed) (or <tt class="docutils literal">a &lt; b</tt>)</li>
<li><tt class="docutils literal">OF</tt> set if two's complement (signed) overflow</li>
</ul>
<p>Condition codes can be set <strong>explicitly</strong> using &quot;test&quot; (<tt class="docutils literal">testl/testq</tt>) instruction such as <tt class="docutils literal">testl a, b</tt> &lt;--&gt; <tt class="docutils literal">a &amp; b</tt> (bitwise <tt class="docutils literal">&amp;</tt>) without setting destination.</p>
<ul class="simple">
<li>Sets condition codes based on value of src1 &amp; src2</li>
<li>Useful to have one of the operands be a mask</li>
<li><tt class="docutils literal">ZF</tt> set if <tt class="docutils literal">a&amp;b == 0</tt></li>
<li><tt class="docutils literal">SF</tt> set if <tt class="docutils literal">a&amp;b &lt; 0</tt></li>
</ul>
<p><strong>Reading Condition Codes</strong></p>
<p><tt class="docutils literal">setX</tt> instruction can be used to read condition code from condition code register and store it into a general purpose register.</p>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[S2 - Integer and Floating Point Numbers]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s2.html"/>
        <published>2013-05-01T00:00:00+05:30</published>
        <updated>2013-05-02T01:48:00+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s2.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <div class="section" id="unsigned-integers">
<h2>Unsigned Integers</h2>
<p>Possible number of values for N bits = 2<sup>N</sup> - 1</p>
<p>Addition/Subtraction can be done with the normal &quot;carry/borrow&quot; rules.</p>
</div>
<div class="section" id="signed-integers">
<h2>Signed Integers</h2>
<p>For unsigned integers example:</p>
<p>8 bits: <tt class="docutils literal">0x00=0</tt>, <tt class="docutils literal">0x01=1</tt>, ..., <tt class="docutils literal">0x7F=127</tt></p>
<p>But we need half of them to be negative.</p>
<p>The high order bit is used to indicate negative. This is called &quot;sign-and-magnitude&quot; representation.</p>
<p>Example:</p>
<ul class="simple">
<li><tt class="docutils literal">0x00</tt> = 00000000<sub>2</sub> is non-negative, because the sign bit is 0</li>
<li><tt class="docutils literal">0x7F</tt> = 01111111<sub>2</sub> is non-negative</li>
<li><tt class="docutils literal">0x85</tt> = 10000101<sub>2</sub> is negative</li>
<li><tt class="docutils literal">0x80</tt> = 10000000<sub>2</sub> is negative</li>
</ul>
<p>But there are two values for <tt class="docutils literal">0</tt><sub>10</sub> : <tt class="docutils literal">0x00</tt> (+0) and <tt class="docutils literal">0x80</tt> (-0).</p>
<p>This can create problems for example:</p>
<p>4 - 3 = <tt class="docutils literal">0100</tt><sub>2</sub> - <tt class="docutils literal">0011</tt><sub>2</sub> = <tt class="docutils literal">0001</tt><sub>2</sub> = 1</p>
<p>4 + (-3) = <tt class="docutils literal">0100</tt><sub>2</sub> + <tt class="docutils literal">1011</tt><sub>2</sub> = <tt class="docutils literal">1111</tt><sub>2</sub> = -7</p>
<p>Therefore, 4 - 3 != 4 + (-3)</p>
<p>We do not want this! Instead what is used is two's complement negatives.</p>
</div>
<div class="section" id="two-s-complement-negatives">
<h2>Two's Complement Negatives</h2>
<p>Rather than having a sign bit as in Signed integers, let the most significant bit have the same value but negative weight.</p>
<p>Example:</p>
<ul class="simple">
<li>unsigned 1010<sub>2</sub> : 1*2<sup>3</sup> + 0*2<sup>2</sup> + 1*2<sup>1</sup> + 0*2<sup>0</sup> = 10<sub>10</sub></li>
<li>2's comp 1010<sub>2</sub> : -1*2<sup>3</sup> + 0*2<sup>2</sup> + 1*2<sup>1</sup> + 0*2<sup>0</sup> = -6<sub>10</sub></li>
</ul>
<p>-1 is represented as <tt class="docutils literal">1111</tt><sub>2</sub>, all negative integers still have MSB = 1. Also, there is only one zero.</p>
<p>To get the negative representation of any integer, take bitwise compliment and then add one!</p>
<p><tt class="docutils literal">~x + 1 = <span class="pre">-x</span></tt></p>
<p>Arithmetic example:</p>
<ul class="simple">
<li>4 + 3 = <tt class="docutils literal">0100</tt> + <tt class="docutils literal">0011</tt> = <tt class="docutils literal">0111</tt> = 7</li>
<li>-4 + 3 = <tt class="docutils literal">1100</tt> + <tt class="docutils literal">0011</tt> = <tt class="docutils literal">1111</tt> = -1</li>
<li>4 - 3 = <tt class="docutils literal">0100</tt> + <tt class="docutils literal">1101</tt> = <tt class="docutils literal">10001</tt> = <tt class="docutils literal">0001</tt> = 1</li>
</ul>
<p>Here in the last example, the highest carry bit is dropped. This is called modular addition.</p>
</div>
<div class="section" id="signed-and-unsigned-numeric-values">
<h2>Signed and Unsigned Numeric Values</h2>
<p>Both signed and unsigned integers have limits. For 4 bit values:</p>
<ul class="simple">
<li>If you compute a number that is too big like 6 + 4 = ? or 15U + 2U = ?</li>
<li>If you compute a numbet that is too small like -7 -3 = ? or 0U - 2U = ?</li>
</ul>
<p>The CPU may be capable of &quot;throwing an exception&quot; for overflow on signed values but it won't for unsigned. C &amp; Java don't give a fuck when this happens and silently cruise along. We need to be careful about this and explicitly check.</p>
</div>
<div class="section" id="values-to-remember">
<h2>Values to remember</h2>
<p>Unsigned Values:</p>
<ul class="simple">
<li>UMin = 0 (<tt class="docutils literal"><span class="pre">000...0</span></tt>)</li>
<li>UMax = 2<sup>w</sup> - 1 (<tt class="docutils literal"><span class="pre">111...1</span></tt>)</li>
</ul>
<p>Two's Complement Values:</p>
<ul class="simple">
<li>TMin = -2<sup>w-1</sup> (<tt class="docutils literal"><span class="pre">100...0</span></tt>)</li>
<li>TMax = 2<sup>w-1</sup> - 1 (<tt class="docutils literal"><span class="pre">011..1</span></tt>)</li>
<li>Negative 1 = <tt class="docutils literal"><span class="pre">111...1</span></tt> or 0xFFFFFFFF (32-bits)</li>
</ul>
<p>Values for W = 16 (16-bit systems)</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="21%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head" rowspan="2">&nbsp;</th>
<th class="head" rowspan="2">Decimal</th>
<th class="head" rowspan="2">Hex</th>
<th class="head" rowspan="2">Binary</th>
</tr>
<tr></tr>
</thead>
<tbody valign="top">
<tr><td>UMax</td>
<td>65535</td>
<td><tt class="docutils literal">FF FF</tt></td>
<td><tt class="docutils literal">11111111 11111111</tt></td>
</tr>
<tr><td>TMax</td>
<td>32767</td>
<td><tt class="docutils literal">7F FF</tt></td>
<td><tt class="docutils literal">01111111 11111111</tt></td>
</tr>
<tr><td>TMin</td>
<td>-32768</td>
<td><tt class="docutils literal">80 00</tt></td>
<td><tt class="docutils literal">10000000 00000000</tt></td>
</tr>
<tr><td>-1</td>
<td>-1</td>
<td><tt class="docutils literal">FF FF</tt></td>
<td><tt class="docutils literal">11111111 11111111</tt></td>
</tr>
<tr><td>0</td>
<td>0</td>
<td><tt class="docutils literal">00 00</tt></td>
<td><tt class="docutils literal">00000000 00000000</tt></td>
</tr>
</tbody>
</table>
<p>Some observations:</p>
<ul>
<li><div class="first line-block">
<div class="line">TMin | = TMax + 1</div>
</div>
</li>
<li><p class="first">UMax = 2 * TMax + 1</p>
</li>
</ul>
</div>
<div class="section" id="integers-in-c">
<h2>Integers in C</h2>
<p>C has support for unsigned and signed numbers with <tt class="docutils literal">#include&lt;limits.h&gt;</tt>. In this header file, there are some contants pre-declared for us such as:</p>
<ul class="simple">
<li>ULONG_MAX</li>
<li>LONG_MAX</li>
<li>LONG_MIN</li>
</ul>
<p>These values are platform specific.</p>
<p><strong>Constants</strong></p>
<ul class="simple">
<li>By default, constants are considered signed integers</li>
<li>Use &quot;U&quot; suffix to force unsigned, e.g. <tt class="docutils literal">0U</tt>, <tt class="docutils literal">4294967259U</tt></li>
</ul>
<p><strong>Casting</strong></p>
<ul class="simple">
<li><tt class="docutils literal">int tx, ty;</tt> - signed integer</li>
<li><tt class="docutils literal">unsigned ux, uy;</tt> - unsigned integer</li>
<li><tt class="docutils literal">tx = (int) ux;</tt> - unsigned casted as signed integer</li>
<li><tt class="docutils literal">uy = (unsigned) ty;</tt> - signed casted as unsigned integer</li>
<li><tt class="docutils literal">tx = ux</tt> - implicit casting also occurs via assignments and function calls</li>
<li><tt class="docutils literal">uy = ty</tt> - same as above</li>
<li>The <tt class="docutils literal">gcc</tt> flag <tt class="docutils literal"><span class="pre">-Wsign-convention</span></tt> produces warning for implicit casts, but <tt class="docutils literal"><span class="pre">-Wall</span></tt> doesn't.</li>
</ul>
<p>Here, the bits are unchanged, they are just interpreted differently.</p>
<p>Some casting surprises:</p>
<ul class="simple">
<li>If signed and unsigned are mixed in a single expression, then signed values are implicitly casted to unsigned.</li>
<li>Including comparision operators &lt;, &gt;, ==, &lt;=, &gt;=</li>
</ul>
</div>
<div class="section" id="shift-operations-for-unsigned-integers">
<h2>Shift operations for Unsigned Integers</h2>
<p>Left Shift: x&lt;&lt;y</p>
<ul class="simple">
<li>Shift bit-vector x left by y positions.</li>
<li>Throw away extra bits on the left and fill with <tt class="docutils literal">0s</tt> on the right.</li>
</ul>
<p>Right Shift: x&gt;&gt;y</p>
<ul class="simple">
<li>Shift bit-vector x right by y positions.</li>
<li>Throw away extra bits on the right and fill with <tt class="docutils literal">0s</tt> on the left.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">00000110</tt> (6)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">00110000</tt> (48)</td>
</tr>
<tr><td>&gt;&gt; 2</td>
<td><tt class="docutils literal">00000001</tt> (1)</td>
</tr>
</tbody>
</table>
<p>Here, when we left-shifted binary of 6 by 3 positions, we multiplied 6 by 2<sup>3</sup> which yielded 48.</p>
<p>When we right-shifted binary of 6 by 2 positions, we divided it by 2<sup>2</sup> which should have yielded 1.5 but since we can't represent fraction, so the result was 1.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">11110010</tt> (242)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">10010000</tt> (144 - wrong)</td>
</tr>
<tr><td>&gt;&gt; 2</td>
<td><tt class="docutils literal">00111100</tt> (60)</td>
</tr>
</tbody>
</table>
<p>Here, when binary of 242 was left-shifted by 3 positions, the result should have been 242 * 2<sup>3</sup> = 1936 but instead we got 144 since 1936 doesn't fits in 8 bit and additional bits on the left were dropped.</p>
<p>When binary of 242 was right-shifted by 2 positions, we got the correct result of 242 / 2<sup>2</sup>  = 60.5 (rounded down to 60).</p>
</div>
<div class="section" id="shift-operations-for-signed-integers">
<h2>Shift operations for signed integers</h2>
<p>Left Shift: x&lt;&lt;y</p>
<ul class="simple">
<li>Equivalent to multiplying x by 2<sup>y</sup> </li>
<li>(if resulting value fits, no 1s are lost)</li>
</ul>
<p>Right Shift: x&gt;&gt;y</p>
<ul class="simple">
<li>Logical Shift (for unsigned values) - fill with 0s on the left</li>
<li>Arithmetic Shift (for signed values) - replicate MSB on left and maintains sign of x</li>
<li>Equivalent to dividing x by 2<sup>y</sup> </li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">01100010</tt> (98)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">00010000</tt> (16 - wrong)</td>
</tr>
<tr><td>Logical &gt;&gt; 2</td>
<td><tt class="docutils literal">00011000</tt> (24)</td>
</tr>
<tr><td>Arithmetic &gt;&gt; 2</td>
<td><tt class="docutils literal">00011000</tt> (24)</td>
</tr>
</tbody>
</table>
<p>Now with a negative integer.</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">x</th>
<th class="head"><tt class="docutils literal">10100010</tt> (-94)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>&lt;&lt; 3</td>
<td><tt class="docutils literal">00010000</tt> (16 - wrong)</td>
</tr>
<tr><td>Logical &gt;&gt; 2</td>
<td><tt class="docutils literal">00101000</tt> (40 - wrong)</td>
</tr>
<tr><td>Arithmetic &gt;&gt; 2</td>
<td><tt class="docutils literal">11101000</tt> (-24)</td>
</tr>
</tbody>
</table>
<p>Here, in the last arithmetic right shift, the MSB 1 instead of 0 was added to the left.</p>
<p>Undefined behavior occurs in C when <tt class="docutils literal">y &lt; 0</tt> or <tt class="docutils literal">y &gt;= word_size</tt>.</p>
</div>
<div class="section" id="using-shifts-and-masks">
<h2>Using Shifts and Masks</h2>
<p>Extract the 2nd most significant byte of an integer.</p>
<ul class="simple">
<li>Let x be <tt class="docutils literal">00110101 01100010 10011010 01010010</tt>.</li>
<li>First we do right shift operation <tt class="docutils literal">x &gt;&gt; 16</tt> and get <tt class="docutils literal">00000000 00000000 00110101 01100010</tt>.</li>
<li>And then we do bitwise <tt class="docutils literal">&amp;</tt> operation with <tt class="docutils literal">0xFF</tt> which in binary is <tt class="docutils literal">00000000 00000000 00000000 11111111</tt>.</li>
<li>The result of the above <tt class="docutils literal">&amp;</tt> operation is <tt class="docutils literal">00000000 00000000 00000000 01100010</tt>.</li>
</ul>
<p>Extract the sign bit of signed integer.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">(x&gt;&gt;31)</span> &amp; 1</tt> - need the <tt class="docutils literal">&amp; 1</tt> to clear out all other bits except LSB.</li>
</ul>
<p>Conditionals as Boolean expressions (assuming x is 0 or 1)</p>
<ul>
<li><p class="first"><tt class="docutils literal">if (x) a=y else a=z;</tt> which is same as <tt class="docutils literal">a = x ? y : z;</tt></p>
</li>
<li><dl class="first docutils">
<dt>Can be re-written (assuming arithmetic right shift) as:</dt>
<dd><p class="first last"><tt class="docutils literal">a = <span class="pre">((x&lt;&lt;31)</span> &gt;&gt; 31) &amp; y + <span class="pre">(((!x)&lt;&lt;31)</span> &gt;&gt; 31) &amp; z;</tt></p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="sign-extension-example">
<h2>Sign Extension Example</h2>
<p>Here, we will convert from smaller to larger integer data type. C automatically performs sign extension.</p>
<div class="highlight"><pre><span class="kt">short</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">;</span> <span class="c1">// 16 bits</span>
<span class="kt">int</span> <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 32 bits</span>
<span class="kt">short</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12345</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">iy</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">y</span><span class="p">;</span>
</pre></div>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="13%" />
<col width="24%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">&nbsp;</th>
<th class="head">Decimal</th>
<th class="head">Hex</th>
<th class="head">Binary</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>x</td>
<td>12345</td>
<td><tt class="docutils literal">30 39</tt></td>
<td><tt class="docutils literal">00110000 01101101</tt></td>
</tr>
<tr><td>ix</td>
<td>12345</td>
<td><tt class="docutils literal">00 00 30 39</tt></td>
<td><tt class="docutils literal">00000000 00000000 00110000 01101101</tt></td>
</tr>
<tr><td>y</td>
<td>-12345</td>
<td><tt class="docutils literal">CF C7</tt></td>
<td><tt class="docutils literal">11001111 11000111</tt></td>
</tr>
<tr><td>iy</td>
<td>-12345</td>
<td><tt class="docutils literal">FF FF CF C7</tt></td>
<td><tt class="docutils literal">11111111 11111111 11001111 11000111</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fractional-binary-numbers">
<h2>Fractional Binary Numbers</h2>
<p>Some examples:</p>
<ul class="simple">
<li><tt class="docutils literal">1011.101</tt><sub>2</sub>  is equal to <tt class="docutils literal">8 + 2 + 1 + 1/2 + 1/8</tt><sub>10</sub> .</li>
<li>5 and 3/4 = <tt class="docutils literal">101.11</tt><sub>2</sub> </li>
<li>2 and 7/8 = <tt class="docutils literal">10.111</tt><sub>2</sub> </li>
<li>63/64 = <tt class="docutils literal">0.111111</tt><sub>2</sub> </li>
</ul>
<p>Observations:</p>
<ul>
<li><p class="first">Divide by 2 by shifting right</p>
</li>
<li><p class="first">Multiply by 2 by shifting left</p>
</li>
<li><dl class="first docutils">
<dt>Numbers of form 0.111111111....<sub>2</sub>  are just below 1.0</dt>
<dd><p class="first last">1/2 + 1/4 + 1/8 + ... + 1/2<sup>i</sup>  + ... ---&gt; 1.0
Shorthand notation for all 1 bits to the right of binary point: 1.0 - e (epsilon)</p>
</dd>
</dl>
</li>
</ul>
<p>Limitations:</p>
<ul>
<li><p class="first">Can only exactly represent numbers that can be written as x * 2<sup>y</sup> </p>
</li>
<li><dl class="first docutils">
<dt>Other rational numbers have repeating bit representations, e.g.:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><tt class="docutils literal">1/3</tt> = 0.0101010101[01]<sub>...2</sub> </dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">1/5</tt> = 0.001100110011[0011]<sub>...2</sub> </li>
<li><tt class="docutils literal">1/10</tt> = 0.0001100110011[0011]<sub>...2</sub> </li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="fixed-point-representations">
<h2>Fixed Point Representations</h2>
<p>We might try representing fractional binary numbers by picking a fixed place for an implied binary point.</p>
<p>Lets do that, using 8-bit fixed point numbers as an example:</p>
<ul>
<li><dl class="first docutils">
<dt>#1 the binary point is between bits 2 and 3</dt>
<dd><p class="first last">b<sub>7</sub> b<sub>6</sub> b<sub>5</sub> b<sub>4</sub> b<sub>3</sub>  [.] b<sub>2</sub> b<sub>1</sub> b<sub>0</sub>  - The maximum value that can be represented with this is 31 and 7/8.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>#2: the binary point is between bits 4 and 5</dt>
<dd><p class="first last">b<sub>7</sub> b<sub>6</sub> b<sub>5</sub>  [.] b<sub>4</sub> b<sub>3</sub> b<sub>2</sub> b<sub>1</sub> b<sub>0</sub>  - The maximum value that can be represented with this is 7 and 31/32.</p>
</dd>
</dl>
</li>
</ul>
<p>The position of the binary point affects the range and precision of the representation.</p>
<ul class="simple">
<li>range: diff between largest and smallest numbers possible</li>
<li>precision: smallest possible difference between any two numbers</li>
</ul>
<p>One of the pros of fixed point representations is that it's simple. The same hardware that does integer arithmetic can do fixed point arithmetic.</p>
<p>But there is a bigger con to it. There is no good way to pick where the fixed point should be. Either the precision or the range has to be sacrificed each time. <strong>This is why fixed point representations are not used.</strong></p>
</div>
<div class="section" id="ieee-floating-point">
<h2>IEEE Floating Point</h2>
<p>It is analogous to scientific notation. For example, we represent 12000000 as 1.2 x 10<sup>7</sup> ; and 0.0000012 as 1.2 x 10<sup>-6</sup> . In C, these can be written as <tt class="docutils literal">1.2e7</tt> and <tt class="docutils literal"><span class="pre">1.2e-7</span></tt> respectively.</p>
<p>This is an IEEE standard established in 1985 for floating point arithmetic and is supported by all major CPUs today. This is fast at hardware level but is numerically well behaved.</p>
</div>
<div class="section" id="floating-point-representation">
<h2>Floating Point Representation</h2>
<p>Numerical form:</p>
<p>V<sub>10</sub>  = (-1)<sup>s</sup>  * M * 2<sup>E</sup> </p>
<ul class="simple">
<li>Sign bit s determines whether the number is negative or positive</li>
<li>Significand (mantissa) M normally a fraction value in range [1.0, 2.0)</li>
<li>Exponent E weights value by a (possibly negative) power of two</li>
</ul>
<p>Representation in memory</p>
<ul class="simple">
<li>MSB s is sign bit s</li>
<li>exp field encodes E (but is not equal to E)</li>
<li>frac field encodes M (but is not equal to M)</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="30%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>exp</td>
<td>frac</td>
</tr>
</tbody>
</table>
<p>Single precision: 32 bits</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>s (1)</td>
<td>exp (8)</td>
<td>frac (23 bits)</td>
</tr>
</tbody>
</table>
<p>Double precision: 64 bits</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>s (1)</td>
<td>exp (11)</td>
<td>frac (52 bits)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="normalization-and-special-values">
<h2>Normalization and Special Values</h2>
<p>Normalized means the mantissa M has the form 1.xxxxxx</p>
<ul class="simple">
<li>0.0011 x 2<sup>5</sup>  and 1.1 x 2<sup>3</sup> represent the same number, but the latter makes better use of the available bits.</li>
<li>Since we know that mantissa starts with a 1, we don't bother to store it thus saving a bit.</li>
</ul>
<p>Now, how do we represent <tt class="docutils literal">0.0</tt>? Or special/undefined values like <tt class="docutils literal">1.0/0.0</tt>?</p>
<p>For these cases, there are some special values reserved for <tt class="docutils literal">exp</tt> and <tt class="docutils literal">frac</tt>.</p>
<ul>
<li><p class="first">A bit pattern <tt class="docutils literal"><span class="pre">00...0</span></tt> represents zero</p>
</li>
<li><dl class="first docutils">
<dt>If <tt class="docutils literal">exp == <span class="pre">11...1</span></tt> and <tt class="docutils literal">frac == <span class="pre">00...0</span></tt>, it represents infinity</dt>
<dd><p class="first last">e.g. 1.0/0.0 = -1.0/-0.0 = +infinity, 1.0/-0.0 = -1.0/0.0 = -infinity</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If <tt class="docutils literal">exp == <span class="pre">11...1</span></tt> and <tt class="docutils literal">frac != <span class="pre">00...0</span></tt>, it represents <tt class="docutils literal">NaN</tt>: <cite>Not a Number</cite>.</dt>
<dd><p class="first last">Results from operations with undefined results, e.g. sqrt(-1), infinity, -infinity, infinity * 0</p>
</dd>
</dl>
</li>
</ul>
<p>Since, <tt class="docutils literal"><span class="pre">000...0</span></tt> and <tt class="docutils literal"><span class="pre">111...1</span></tt> are already reserved above as special values, we can't use them.</p>
<p>So, the condition: <tt class="docutils literal">exp != <span class="pre">000...0</span> and exp != <span class="pre">111...1</span></tt>.</p>
<p><strong>Exponent is coded as biased value:</strong> <tt class="docutils literal">E = exp - Bias</tt></p>
<ul>
<li><p class="first"><tt class="docutils literal">exp</tt> is an unsigned value ranging from 1 to 2<sup>k</sup>  - 2 (k == # bits in the <tt class="docutils literal">exp</tt>)</p>
</li>
<li><dl class="first docutils">
<dt>Bias = 2<sup>k-1</sup>  - 1</dt>
<dd><ul class="first last simple">
<li>Single precision: 127  (so exp: 1...254, E: -126...127)</li>
<li>Double precision: 1023 (so exp: 1...2046, E: -1022...1023)</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">This enables negative values for E, for representing very small values.</p>
</li>
</ul>
<p><strong>Significand coded with implied leading 1</strong>: <tt class="docutils literal">M = <span class="pre">1.xxx...x</span></tt><sub>2</sub> </p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">xxx...x</span></tt>: the n bits of frac</li>
<li>Minimum when 000...0 (M = 1.0)</li>
<li>Maximum when 111...1 (M = 2.0 - e(epsilon))</li>
<li>Get extra leading bit for &quot;free&quot;</li>
</ul>
</div>
<div class="section" id="normalized-encoding-example">
<h2>Normalized Encoding Example</h2>
<p><strong>Value</strong>: <tt class="docutils literal">float f = 12345.0;</tt> (with single precision, 32-bits)</p>
<p><tt class="docutils literal">12345</tt><sub>2</sub>  = <tt class="docutils literal">11000000111001</tt><sub>2</sub>  = <tt class="docutils literal">1.1000000111001</tt><sub>2</sub>  x 2<sup>13</sup> </p>
<p><strong>Singnificand</strong>:</p>
<p>M    = <tt class="docutils literal">1.1000000111001</tt><sub>2</sub> frac = <tt class="docutils literal">10000001110010000000000</tt><sub>2</sub> </p>
<p><strong>Exponent</strong>: E = exp - Bias, so exp = E + Bias</p>
<p>E = 13, Bias = 127, so exp = 140 = <tt class="docutils literal">10001100</tt><sub>2</sub> </p>
<p>Result</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="29%" />
<col width="58%" />
</colgroup>
<tbody valign="top">
<tr><td>s (1)</td>
<td>exp (8)</td>
<td>frac (23 bits)</td>
</tr>
<tr><td>0</td>
<td>10001100</td>
<td>10000001110010000000000</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="floating-point-operations">
<h2>Floating Point Operations</h2>
<p>Unlike the representation for integers, the representation for floating-point number is not exact because mantissa doesn't go on forever and stops at 23 bits or even 52 bits in double precision.</p>
<p>Basic idea:</p>
<ul>
<li><p class="first">First, compute the exact result</p>
</li>
<li><dl class="first docutils">
<dt>Then, round the result to make it fit into desired precision:</dt>
<dd><ul class="first last simple">
<li>Possibly overflow if the exponent is too large</li>
<li>Possibly drop least significant bits of significand to fit into <tt class="docutils literal">frac</tt></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>For rounding a value, there are many possible rounding modes like round towards zero, round down, round up, round to nearest value and round to even. With most of these values, errors start accumulating when rounding is repeated on the same value and this causes statistical bias. However, with round to even avoids this bias by rounding up about half the time and rounding down half the time. The <strong>default rounding mode for IEEE floating point is Round-to-even</strong>.</p>
<p>If overflow of the exponent occurs, result will be infinity or -infinity. Floats with value of inifinity, -inifinity and NaN can be used in operations but the result is usually still inifinity, -inifinity, or NaN.</p>
<p><strong>Floating point operations are not always associative or distributive, due to rounding!</strong></p>
<ul class="simple">
<li>(3.14 + 1e10) - 1e10 != 3.14 + (1e10 - 1e10)</li>
<li>1e20 * (1e20 - 1e20) != (1e20 * 1e20) - (1e20 * 1e20)</li>
</ul>
<p>Here, in the first example, in the LSH, when <tt class="docutils literal">(3.14 + 1e10)</tt> is computed, <tt class="docutils literal">3.14</tt> so small against <tt class="docutils literal">1e10</tt> that after adding these two and trying to fit it into the 23 bits, the least significant bits are dropped and thus the result is <tt class="docutils literal">1e10</tt>. So, LSH computes to <tt class="docutils literal">1e10 - 1e10 = 0</tt>. While on the RHS, <tt class="docutils literal">3.14 + (1e10 - 1e10) = 3.14</tt>.</p>
<p>In the second example, LSH simply computes to <tt class="docutils literal">0</tt>. While on the RHS, <tt class="docutils literal">(1e20 * 1e20)</tt> causes overflow and results infinity. So, RHS computes to <tt class="docutils literal">infinity - infinity = infinity</tt>.</p>
</div>
<div class="section" id="floating-point-in-c">
<h2>Floating Point in C</h2>
<p>C offers two levels of precision</p>
<ul class="simple">
<li><tt class="docutils literal">float</tt> - single precision (32-bit)</li>
<li><tt class="docutils literal">double</tt> - double precision (64-bit)</li>
</ul>
<p>Default rounding mode is round-to-even. There is a header file <tt class="docutils literal">#include &lt;math.h&gt;</tt> to get INFINITY and NAN constants.</p>
<p><strong>Equality comparisions ``==`` between floating point numbers are tricky, and ofter return unexpected results. AVOID THEM!!!</strong> Rather, subtract them and test if the value is small.</p>
</div>
<div class="section" id="coversion-between-data-types">
<h2>Coversion between data types</h2>
<p>Casting between int, float, and double changes the bit representation.</p>
<ul class="simple">
<li><tt class="docutils literal">int <span class="pre">--&gt;</span> float</tt> - May be rounded but overflow not possible since float can accomodate much larger values than int.</li>
<li><tt class="docutils literal">int <span class="pre">--&gt;</span> double</tt> - Exact conversion as long as int has &lt;= 53-bit word size since double has 52 bits for mantissa part (the leading 1 is not stored to the int can be 52+1 bit long) else rounding occurs.</li>
<li><tt class="docutils literal">float <span class="pre">--&gt;</span> double</tt> - Exact conversion since float is 32-bits and 64-bits, so double can definitely store a float representation in it.</li>
<li><tt class="docutils literal">double or float <span class="pre">--&gt;</span> int</tt> - Fractional part is truncated (rounded towards zero). And if the double/float representation is too large or too small, then int is generally set as Tmin or NaN or infinity...</li>
</ul>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>Zero</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>0</td>
<td>00000000</td>
<td>00000000000000000000000</td>
</tr>
</tbody>
</table>
<p>Normalized values</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="51%" />
<col width="42%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>1 to 2<sup>k</sup> -2</td>
<td>significand = 1.M</td>
</tr>
</tbody>
</table>
<p>Infinity</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>11111111</td>
<td>00000000000000000000000</td>
</tr>
</tbody>
</table>
<p>NaN</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>11111111</td>
<td>non-zero</td>
</tr>
</tbody>
</table>
<p>Denormalized values</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="26%" />
<col width="66%" />
</colgroup>
<tbody valign="top">
<tr><td>s</td>
<td>00000000</td>
<td>significand = 0.M</td>
</tr>
</tbody>
</table>
<p>As with integers, float suffers from fixed number of bits available to represent them.</p>
<ul class="simple">
<li>Can get overflow/underflow, just like ints</li>
<li>Some &quot;simple fractions&quot; have no exact representations (e.g. 0.2)</li>
<li>Can also lose precision, unlike ints. Every operation gets a slightly wrong result.</li>
</ul>
<p>Mathematically equivalent ways of writing an expression may compute differet results.</p>
<p>Never test floating point values for equality.</p>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[S1 - Memory, Data and Addressing]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/hw-sw-interface-s1.html"/>
        <published>2013-04-30T00:00:00+05:30</published>
        <updated>2013-05-03T19:01:15+05:30</updated>
        <id>http://vivek.im/notes/notes/hw-sw-interface-s1.html</id>
        <category scheme="http://vivek.im/notes/tag/hwswint/" term="hwswint" label="hwswint" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <div class="section" id="performance">
<h2>Performance</h2>
<p>Performance is not just about CPU clock speed. Data and instructions reside in the memory and they must be fetched to the CPU from memory to operate upon.</p>
<p>CPU&lt;-&gt;Memory bandwidth can bottleneck performance. Two things can be done for this:</p>
<ul class="simple">
<li>Increase memory bandwidth so that more data can travel at a time. (DDR1 -&gt; DDR2 -&gt; DDR3)</li>
<li>Move less data into/out of the CPU. This can be achieved by putting a small amount of memory on the CPU itself (which is called cache memory).</li>
</ul>
</div>
<div class="section" id="binary-representations">
<h2>Binary Representations</h2>
<p>0s and 1s are represented by high and low voltage. It takes a little bit of time while changing the voltage and it is what limits the speed of the computing system. Electronics are designed to only care about the two specific voltages for 0 and 1 and not care about the voltages in between.</p>
</div>
<div class="section" id="representing-information-as-bits-and-bytes">
<h2>Representing information as bits and bytes</h2>
<p>We're going to group our binary digits into groups of eight which are called <strong>bytes</strong>. The range can be-</p>
<p><tt class="docutils literal">00000000</tt><sub>2</sub> - <tt class="docutils literal">11111111</tt><sub>2</sub></p>
<p>In decimal, the above range can be expressed as-</p>
<p><tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">255</tt><sub>10</sub></p>
<p>But using binary form to represent data in our programs can get tedious so hexadecimal form is used. Each hexadecimal digit is 4 bit long. A byte can also be represented as two hexadecimal digits. The range can be-</p>
<p><tt class="docutils literal">00</tt><sub>16</sub> - <tt class="docutils literal">FF</tt><sub>16</sub> (which is also same as <tt class="docutils literal">0</tt><sub>10</sub> - <tt class="docutils literal">225</tt><sub>10</sub>)</p>
<p>In C, <tt class="docutils literal">FA1D37B</tt><sub>16</sub> can be represented as <tt class="docutils literal">0xFA1D37B</tt> or <tt class="docutils literal">0xfa1d37b</tt>. This is an 8 digit hexadecimal number, so it is 8 x 4 bit = 32 bits or 4 bytes long number.</p>
</div>
<div class="section" id="byte-oriented-memory-organization">
<h2>Byte Oriented Memory Organization</h2>
<p>Memory is organized in bytes. Basically it is a big long array of bytes. Each byte has an address.</p>
</div>
<div class="section" id="machine-words">
<h2>Machine Words</h2>
<p>Machine has a &quot;word size&quot;.</p>
<p>Until recently, most machines used 32-bit (4-byte) words. It limited address to 4GB (2^32 bytes) and it has become too small for memory intensive applications.</p>
<p>Now, most x86 systems use 64-bit (8-byte) words which has potential address space of 2<sup>64</sup> ~ 1.8 x 10<sup>19</sup> bytes (18EB - exabytes).</p>
<p>For backward compatibility, many CPUs support different word sizes of 16-bit, 8-bit, 4-bit, 2-bit and 1-bit.</p>
</div>
<div class="section" id="word-oriented-memory-organization">
<h2>Word Oriented Memory Organization</h2>
<p>Addresses specify location of bytes in memory and each byte has an address.</p>
<p>In 32-bit systems, 4 bytes have to be grouped together into a word. And 64-bit systems have 8 byte words. So, what address do we give to those word with multiple bytes?</p>
<p>To maintain uniformity, address of a word is said to be the address of its first byte. [Refer to the last slide in <tt class="docutils literal"><span class="pre">lecture_slides_01_012-memorg.pdf</span></tt>]</p>
<p>Pointer is a data object that contains an address.</p>
</div>
<div class="section" id="byte-ordering">
<h2>Byte Ordering</h2>
<p>Say you want to store the 4-byte word <tt class="docutils literal">0xaabbccdd</tt>. In what order will the bytes be stored? There are two different conventions for that.</p>
<p>Big Endian and Little Endian. (Origin: Gulliver's Travels)</p>
<p><strong>Big Endian</strong>: The most significant byte of the number goes the lowest address.</p>
<p><strong>Little Endian</strong>: The least significant byte of the number goes the lowest address.</p>
<p>Example -</p>
<p>Variable has 4-byte representation <tt class="docutils literal">0x01234567</tt> and address of variable is <tt class="docutils literal">0x100</tt>.</p>
<p><strong>Big Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>01</td>
<td>23</td>
<td>45</td>
<td>67</td>
</tr>
</tbody>
</table>
<p><strong>Little Endian</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr><td>0x100</td>
<td>0x101</td>
<td>0x102</td>
<td>0x103</td>
</tr>
<tr><td>67</td>
<td>45</td>
<td>23</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>x86 architecture uses little endian convention.</p>
</div>
<div class="section" id="address-and-pointers-in-c">
<h2>Address and Pointers in C</h2>
<p>Variable declaration: <tt class="docutils literal">int x, y;</tt></p>
<p>The two variables will find two locations in memory in which to store 2 integers (1 word each).</p>
<p>Pointer declaration: <tt class="docutils literal">int *ptr;</tt></p>
<p>Declares a variable <tt class="docutils literal">ptr</tt> that is a pointer to a data item that in an integer. This will store an address rather than a value.</p>
<p>Assignment to a pointer: <tt class="docutils literal">ptr = &amp;x;</tt></p>
<p>This assigns ptr to point to the address where x is located. <tt class="docutils literal">&amp;</tt> is used to get the address of a variable.</p>
<p>Dereference operator (<tt class="docutils literal">*</tt>) is used to get the value pointed to by a pointer. <tt class="docutils literal">*ptr</tt> will give us the value at the memory address given by the value of <tt class="docutils literal">ptr</tt>.</p>
<p>Examples</p>
<ul class="simple">
<li>If <tt class="docutils literal">ptr = &amp;x;</tt> then <tt class="docutils literal">y = *ptr + 1</tt> is same as <tt class="docutils literal">y = x + 1</tt>.</li>
<li><tt class="docutils literal"><span class="pre">*(&amp;y)</span></tt> is equivalent to <tt class="docutils literal">y</tt>.</li>
</ul>
<p>We can do arithmetic on pointers.</p>
<p><tt class="docutils literal">ptr = ptr + 1</tt> - Since type of ptr is int and an int uses 4 bytes, C automatically adds (1 x 4 =) 4. But this can be dangerous if we don't exactly know what is present at the next memory address.</p>
</div>
<div class="section" id="assignment-in-c">
<h2>Assignment in C</h2>
<p>Left-Hand-Side = Right-Hand-Side</p>
<p>LHS must evaluate to a memory location (variable).</p>
<p>RHS must evaluate to a value (could be an address).</p>
<p><tt class="docutils literal">int x, y; x = y + 3;</tt> - Get value at y, add 3, put it in x</p>
<p><tt class="docutils literal">int *x; int y; x = &amp;y + 3;</tt> - Get address of y, add (3 x 4 =) 12 to it, put it in x</p>
<p><tt class="docutils literal">*x = y;</tt> - Here <tt class="docutils literal">*</tt> says to the compiler not to use <tt class="docutils literal">x</tt> itself as the variable rather get the value stored at x, interpret it as an address, put value of y at that address.</p>
</div>
<div class="section" id="arrays">
<h2>Arrays</h2>
<p>Arrays represent adjacent locations in memory that store same type of data objects. E.g. <tt class="docutils literal">int big_array[128];</tt> allocates 512 adjacent bytes (size of int- 4 bytes x 128) in memory.</p>
<div class="highlight"><pre><span class="cm">/* Lets assume that array starts at 0x00ff0000 */</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">array_ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">big_array</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="n">big_array</span><span class="p">;</span> <span class="cm">/* 0x00ff0000 */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* 0x00ff0000 */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">big_array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="n">array_ptr</span> <span class="o">=</span> <span class="n">big_array</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (adds 3 * size of int) */</span>
<span class="o">*</span><span class="n">array_ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">array_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 0x00ff000c (but big_array[3] is incremented) */</span>
</pre></div>
<p>For <tt class="docutils literal">array_ptr = big_array;</tt>, when C sees that we are trying to assign an array to a different variable that is a pointer, it automatically assigns the memory address of the array.</p>
<p>The last one is a bit complicated. Lets first see RHS. <tt class="docutils literal">*array_ptr</tt> gets the value pointed to by the pointer <tt class="docutils literal">array_ptr</tt> which is <tt class="docutils literal">big_array[3]</tt> as seen in second-last line. Now in LHS, <tt class="docutils literal">*array_ptr</tt> says to go to the location pointed to by <tt class="docutils literal">array_ptr</tt> which is the address of <tt class="docutils literal">big_array[3]</tt>. So, in effect, it is equivalent to psuedo-code <tt class="docutils literal">big_array[3] = big_array[3] + 1</tt>.</p>
<p><tt class="docutils literal">array_ptr = &amp;big_array[130];</tt> - The array was only 128 element long but we are asking for index 130. But C doesn't give a fuck. It applies the same arithmetic calculation (adding 130 * size of int) and gives back address <tt class="docutils literal">0x00ff0208</tt>. Beware of this!</p>
<p>In general, <tt class="docutils literal">&amp;big_array[i]</tt> is same as <tt class="docutils literal">(big_array + i)</tt>, which implicitly computes <tt class="docutils literal">&amp;big_array[0] + i * <span class="pre">sizeof(big_array[0]);</span></tt></p>
</div>
<div class="section" id="representing-strings">
<h2>Representing strings</h2>
<p>A C-style string is represented by an array of bytes. Elements are one-byte ASCII codes for each character. A 0 byte marks the end of the array.</p>
<p><tt class="docutils literal">char S[4] = &quot;lola&quot;;</tt></p>
<p>Getting the address of an integer in the memory.</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">show_bytes</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%p</span><span class="se">\t</span><span class="s">0x%.2x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">show_int</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">show_bytes</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>First argument for <tt class="docutils literal">show_bytes</tt> function is the address of the starting location in memory. It is a pointer pointing to the character (which are of size one byte). Second argument is the length of bytes we want to print. <tt class="docutils literal">%p</tt> is for printing pointer and <tt class="docutils literal">%x</tt> is for printing a value as hex and <tt class="docutils literal">%.2x</tt> is for printing the value as two digit hex.</p>
<p>In <tt class="docutils literal">show_int</tt> function, while passing the first parameter, <tt class="docutils literal">&amp;x</tt> is address of an integer, but by <tt class="docutils literal">(char *) &amp;x</tt>, we are casting it as an address of character.</p>
</div>
<div class="section" id="boolean-algebra">
<h2>Boolean Algebra</h2>
<p>Encode &quot;True&quot; as 1 and &quot;False&quot; as 0.</p>
<ul class="simple">
<li>AND: A&amp;B = 1 when both A is 1 and B is 1</li>
<li>OR: A|B = 1 when either A is 1 or B is 1 or both</li>
<li>XOR: A^B = 1 when either A is 1 or B is 1, but not both</li>
<li>NOT: ~A = 1 when A is 0 and vice-versa</li>
</ul>
<p>DeMorgan's Law: <tt class="docutils literal">~(A|B) = ~A &amp; ~B</tt></p>
</div>
<div class="section" id="bitwise-operations">
<h2>Bitwise Operations</h2>
<p>Bitwise operators <tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">|</tt>, <tt class="docutils literal">^</tt>, <tt class="docutils literal">~</tt> are available in C.
They can be applied to any &quot;integral&quot; data types (long, int, short, char). Operations are applied bitwise.</p>
<p>Examples:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x41</span><span class="p">;</span> <span class="cm">/* 0x41 -&gt; 01000001 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>         <span class="cm">/* 10111110 -&gt; 0xBE */</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>    <span class="cm">/* 0x00 -&gt; 00000000 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span><span class="p">;</span>         <span class="cm">/* 11111111 -&gt; 0xFF */</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x69</span><span class="p">;</span> <span class="cm">/* 0x69 -&gt; 01101001 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mh">0x55</span><span class="p">;</span> <span class="cm">/* 0x55 -&gt; 01010101 */</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>      <span class="cm">/* 01000001 -&gt; 0x41 */</span>
</pre></div>
</div>
<div class="section" id="logic-operations">
<h2>Logic Operations</h2>
<p>Logical operators in C: <tt class="docutils literal">&amp;&amp;</tt>, <tt class="docutils literal">||</tt> and <tt class="docutils literal">!</tt>. <tt class="docutils literal">0</tt> is viewed as false and any non-zero value is treated as true. Early termination occurs where possible.</p>
<p>Examples:</p>
<ul class="simple">
<li><tt class="docutils literal">!0x41</tt>         --&gt; <tt class="docutils literal">0x00</tt></li>
<li><tt class="docutils literal">!0x00</tt>         --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">0x69 &amp;&amp; 0x55</tt>  --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">0x00 &amp;&amp; 0x55</tt>  --&gt; <tt class="docutils literal">0x00</tt></li>
<li><tt class="docutils literal">0x69 || 0x55</tt>  --&gt; <tt class="docutils literal">0x01</tt></li>
<li><tt class="docutils literal">p &amp;&amp; *p++</tt> (avoids null pointer access <tt class="docutils literal">0x00000000</tt>)</li>
</ul>
<p>In the last one, if p is a null pointer (false), then the <cite>and</cite> operation will short-circuit and <tt class="docutils literal">*p++</tt> won't be executed. It is short for <tt class="docutils literal">if (p) { <span class="pre">*p++;</span> }</tt>.</p>
</div>
<div class="section" id="representing-manipulating-sets">
<h2>Representing &amp; Manipulating Sets</h2>
<p>Bit vectors can be used to represent sets.</p>
<p>Width w bit vector represents of {0,...,w-1}</p>
<p>a<sub>j</sub>= 1 if j in A - each bit in the vector represents the absence (0) or presence (1) of an element in the set.</p>
<blockquote>
<p>01101001</p>
<p>76543210</p>
</blockquote>
<p>The set here is {0, 3, 5, 6}.</p>
<blockquote>
<p>01010101</p>
<p>76543210</p>
</blockquote>
<p>And the set here is {0, 2, 4, 6}.</p>
<p>Operations:</p>
<ul class="simple">
<li><tt class="docutils literal">&amp;</tt> Intersections        --&gt; 01000001 {0, 6}</li>
<li><tt class="docutils literal">|</tt> Union                --&gt; 01111101 {0, 2, 3, 4, 5, 6}</li>
<li><tt class="docutils literal">^</tt> Symmetric difference --&gt; 00111100 {2, 3, 4, 5}</li>
<li><tt class="docutils literal">~</tt> Complement           --&gt; 10101010 {1, 3, 5, 7}</li>
</ul>
</div>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[JavaScript Basics]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/javascript-basics.html"/>
        <published>2013-03-27T00:00:00+05:30</published>
        <updated>2013-04-03T05:48:41+05:30</updated>
        <id>http://vivek.im/notes/notes/javascript-basics.html</id>
        <category scheme="http://vivek.im/notes/tag/javascript/" term="javascript" label="javascript" />
        <category scheme="http://vivek.im/notes/tag/basics/" term="basics" label="basics" />
        <category scheme="http://vivek.im/notes/tag/notes/" term="notes" label="notes" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>The core language features of JavaScript are defined in ECMA-262 as a pseudolanguage named ECMAScript. ECMAScript contains all of the basic syntax, operators, data types, and objects necessary to complete basic computing tasks, though it provides no way to get input or to produce output. Understanding ECMAScript and its intricacies is vital to a complete understanding of JavaScript as implemented in web browsers.</p>
<p><strong>Data types</strong></p>

<ul>
<li>undefined - for undefined variables</li>
<li>null - empty object pointer</li>
<li>boolean - true or false</li>
<li>string</li>
<li>number</li>
<li>object</li>
<li>function</li>
</ul>
<p>Variable initiliazation</p>

<pre><code>::js
var abc = &quot;lola&quot;; // creates local variable
xyz = &quot;loli;&quot; // creates global variable (bad)</code></pre>
<p>Type checking</p>

<pre><code>::js
typeof any_uninitialized_variable; // undefined

var spam;
typeof undefined; // undefined</code></pre>
<p>undefined is unpredictable. You won&#39;t know if the variable has been just initialized or it hasn&#39;t.</p>

<ul>
<li>Don&#39;t set value of any variable to undefined explicitly.</li>
<li>Any time an object is expected but is not available, null should be used in its place.</li>
</ul>
<p>Because storing floating-point values uses twice as much memory as storing integer values, ECMAScript always looks for ways to convert values into integers.</p>

<pre><code>::js
var someNum = 22.0; // interpreted as integer 22</code></pre>
<p>There is a special numeric value called <strong>NaN</strong>, short for Not a Number, which is used to indicate when an operation intended to return a number has failed (as opposed to throwing an error).</p>

<ul>
<li>Dividing a number by 0 gives NaN.</li>
<li>Any operation involving NaN returns NaN.</li>
</ul>
<p>NaN&#39;s peculiar behavior.</p>

<pre><code>::js
NaN == NaN; // returns false</code></pre>
<p>Use isNaN(); function to check for NaN.</p>

<pre><code>::js
isNaN(&quot;11&quot;); // false - can be converted to 11
isNaN(&quot;lola&quot;); // true - cannot be converted to a number
isNaN(true); // false - can be converted to 1</code></pre>
<p><strong>Numbers</strong></p>

<pre><code>::js
Number(&quot;100 Cats&quot;); // NaN
Number(&quot;100&quot;); // 100
Number(&quot;&quot;); // 0
Number(true); // 1
Number(&quot;000010&quot;); // 10 (leading 0s are ignored)</code></pre>
<p>Because of the complexities and oddities of the Number() function when converting strings, the parseInt() function is usually a better option when you are dealing with integers.</p>

<pre><code>::js
parseInt(&quot;100 Cats 323&quot;); // 100
parseInt(&quot;Cats 100 203&quot;); // NaN</code></pre>
<p>If this first character isnt a number, the minus sign, or the plus sign, parseInt() always returns NaN, which means the empty string returns NaN (unlike with Number(), which returns 0).</p>
<p>Radix can be passed as second argument to parseInt(). It is a good idea to pass the value (10 for decimals, 2 for binary, 8 for octal and 16 for hexadecimal) to avoid any errors.</p>
<p><strong>Strings</strong></p>
<p>Strings are immutable in ECMAScript like in Python. To change the string value held by a variable, it must be destroyed and replaced with the new one.</p>
<p>A value can be converted to string easily by adding &ldquo;&rdquo; to it.</p>

<pre><code>::js
9 + &quot;&quot;; // &quot;9&quot;</code></pre>
<p><strong>Boolean</strong></p>
<p>Logical NOT can be performed with ! sign before the value.</p>
<p>Logical AND: &amp;&amp;</p>
<p>Logical OR: ||</p>

<pre><code>::js
null == undefined; //true
&quot;NaN&quot; == NaN; //false
5 == NaN; //false
NaN == NaN; //false
NaN =! NaN; //true
false == 0; //true
true == 1; //true
true == 2; //false
undefined == 0; //false
null == 0; //false
&quot;5&quot; == 5; //true
&quot;5&quot; === 5; //false</code></pre>
<p>=== does comparison without type conversion.</p>
<p><strong>Conditional Operator</strong></p>

<pre><code>::js
variable = boolean_expression ? true_value : false_value;
var max = (num1 &gt; num2) ? num1 : num2;</code></pre>
<p><strong>if Statement</strong></p>

<pre><code>::js
if (condition) {
    statement1;
} else if {
     statement2;
} else {
     statement3;
}</code></pre>
<p><strong>do Statement</strong></p>

<pre><code>::js
do {
    statement;
} while (expression);</code></pre>
<p><strong>while Statement</strong></p>

<pre><code>::js
while (expression) {
    statement;
}</code></pre>
<p><strong>for Statement</strong></p>
<p>Nothing can be done with a for loop that cant be done using a while loop. The for loop simply encapsulates the loop-related code into a single location.</p>

<pre><code>::js
for (initialization; expression; post-loop-expression) {
    statement;
}

for (var i=0; i&lt;=5; i++) {
    alert(i);
}</code></pre>
<p><strong>for-in Statement</strong></p>

<pre><code>::js
for (property in expression) {
    statement;
}</code></pre>
<p><strong>Labeled Statement</strong></p>
<p>Statements can be labeled using following syntax. Mostly used in loops to break out the outer loop.</p>

<pre><code>::js
label: statement;</code></pre>
<p><strong>with Statement</strong></p>
<p>The with statement sets the scope of the code within a particular object.</p>

<pre><code>::js
with (expression) {
    statement;
}</code></pre>
<p>Example:</p>

<pre><code>::js
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;</code></pre>
<p>can be rewritten as:</p>

<pre><code>::js
var qs = search.substring(1);
var hostName = hostname;
var url = href;</code></pre>
<p>Note: It is widely considered a poor practice to use the with statement in production code because of its negative performance impact and the difficulty in debugging code contained in the with statement.</p>
<p><strong>switch Statement</strong></p>

<pre><code>::js
switch (expression) {
    case value/expression: statement;
    break;
    case value/expression: statement;
    break;
    default: statement;
}</code></pre>
<p>Each case in a switch statement says, If the expression is equal to the value, execute the statement. The break keyword causes code execution to jump out of the switch statement. Without the break keyword, code execution falls through the original case into the following one.</p>

<h2 id="toc_0">Functions</h2>

<pre><code>::js
function functionName(arg1, arg2,, argN) {
    statements
}</code></pre>
<p>Function arguments in ECMAScript dont behave in the same way as function arguments in most other languages. <strong>An ECMAScript function doesnt care how many arguments are passed in</strong>, nor does it care about the data types of those arguments. Just because you define a function to accept two arguments doesnt mean you can pass in only two arguments. You could pass in one or three or none, and the interpreter wont complain. This happens because arguments in ECMAScript are represented as an array internally.</p>
<p>There is an arguments object that can be accessed inside a function which contains all the passed in arguments. Individual arguments can be accessed by using index notation.</p>
<p>All arguments in ECMAScript are passed by value. It is not possible to pass arguments by reference.</p>
<p>Functions that don&#39;t return any value explicitly actually return undefined.</p>
<p><strong>Primitive and Reference Values</strong></p>
<p>ECMAScript variables may contain two different types of data: primitive values and reference values.</p>
<p><strong>Primitive Values</strong> - Simple atomic pieces of data. These are accessed by value. These are undefined, null, number, string and boolean.</p>
<p><strong>Reference Values</strong> - Objects that may be made up of multiple values. JavaScript does not permit direct access of memory locations, so direct manipulation of the objects memory space is not allowed. When you manipulate an object, <strong>youre really working on a reference to that object rather than the actual object itself</strong>. For this reason, such values are said to be accessed by reference.</p>

<ul>
<li>When copying primitive values, stored value in one variable is hard copied to the other variable. They then have nothing to do with each other.</li>
<li>Whereas when copying reference values, pointer from one variable is simply copied to the other variable, both of which point to the same object stored on the heap. Changes made to the object with access from any of the variable affects all the other ones.</li>
</ul>
<p>Now, let&#39;s focus on argument passing. All function arguments in ECMAScript are passed by values. This means that the value outside of the function is copied into an argument on the inside of the function the same way a value is copied from one variable to another.</p>
<p>When the argument is passed by value, the value is copied into a local variable (a named argument is available and in arguments object). This happens in accordance to the rules mentioned above.</p>
<p>In case of reference values when passed in arguments, a local copy of the pointer is made but they both still point to the same object. Changes made to the object inside the function will reflect even outside of it.</p>
<p>It can be checked whether the variable contains primitive or reference value by using isinstanceof operator with following syntax.</p>

<pre><code>::js
result = variable isinstanceof constructor;

person isinstanceof Object;
colors isinstanceof Array;</code></pre>
<p>All reference values, by definition, are instances of Object, so the instanceof operator always returns true when used with a reference value and the Object constructor. Similarly, if instanceof is used with a primitive value, it will always return false, because primitives arent objects.</p>
<p><strong>Execution Context and Scope</strong></p>
<p>There are mainly two execution context (or scope) which are at global and function level. Also the with statement and the catch block in try-catch statement have their own execution context.</p>
<p>If var is omitted while initializing a variable inside of a function, it is created in global context.</p>

<h2 id="toc_1">Reference Types</h2>
<p>A reference value (object) is an instance of a specific reference type. In ECMAScript, reference types are structures used to group data and functionality together and are often incorrectly called classes.</p>
<p><strong>Object Type</strong></p>
<p>Can be created in two ways:</p>

<pre><code>::js
var person = new Object();
person.name = &quot;lola&quot;;

//or

var person = {
    name: &quot;lola&quot;;
}</code></pre>
<p>Object properties can be accessed using dot notation as well as using bracket notation.</p>

<pre><code>::js
person.name;
person[&quot;name&quot;]; // both are same</code></pre>
<p><strong>Array Type</strong></p>
<p>ECMAScript arrays are dynamically sized. A same array can hold any data type in each slot. Can be created in following ways:</p>

<pre><code>::js
var colors = new Array(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;);
var colos = Array(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;);
var colors = [&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;];</code></pre>
<p>Elements can be accessed using bracket notation. Arrays have length property with which the size of an array can be known. By setting the length property, you can easily remove items from or add items to the end of the array.</p>
<p><strong>Array Methods</strong></p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[Scala Basics]]></title>
        <author><name>Vivek Agarwal</name></author>
        <link href="http://vivek.im/notes/notes/scala-basics.html"/>
        <published>2013-03-27T00:00:00+05:30</published>
        <updated>2013-04-03T05:55:37+05:30</updated>
        <id>http://vivek.im/notes/notes/scala-basics.html</id>
        <category scheme="http://vivek.im/notes/tag/scala/" term="scala" label="scala" />
        <category scheme="http://vivek.im/notes/tag/basics/" term="basics" label="basics" />
        <content type="html" xml:base="http://vivek.im/notes/" xml:lang="en">
            <![CDATA[ <p>Imperative Programming is about</p>

<ul>
<li>modifying mutable variables,</li>
<li>using assignments</li>
<li>and control structures such as if-then-else, loops, breaks, continue, return.</li>
</ul>
<p>Pure imperative programming is limited by the Von Neumann bottleneck:</p>

<blockquote>
<p>One tends to conceptualize data structures word-by-word.</p>
</blockquote>
<p>We need other techniques for dening high-level abstractions such as collections, polynomials, geometric shapes, strings, documents.</p>
<p>A theory consists of one or more data types, operation on these data types and laws that describe the relationship between values and operations.</p>
<p>Normally, a theory doesn&#39;t describes mutations!</p>
<p>Functional Programming is about</p>

<ul>
<li>In a restricted sense, it means programming without mutable variables, assignments, loops and other imperative control stuctures.</li>
<li>In a wider sense, functional programming means focusing on the functions to construct elegant programs.</li>
<li>In particular, functions can be values that are produced, consumed and composed.</li>
<li>Functions are first class citizens. They can be defined anywhere, including inside other functions.</li>
<li>Functions like any other value, passed as parameter to functions and returned as results. As for other values, there exists a set operators to compose
functions.</li>
</ul>
<p>Functional Programming is becoming increasingly popular because it oers an attractive method for exploiting parallelism for multicore and cloud computing.</p>
<p>In a parallel environment, when multiple threads try to access and mutate a shared mutable state, problems arises. Though there are ways to solve it, it is not always easy and elegant as desired. In functional programming, by eliminating the use of mutable states these problems can be easily solved.</p>
<p>Functions can be defined as:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span> <span class="n">sumOfSquares</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">square</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>

<span class="cm">/* Here, the return type is defined as well. */</span>
<span class="k">def</span> <span class="n">power</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
<p><strong>Call by value (CBV)</strong> - All the arguments are evaluated to a simple value and then passed on to the function body as soon as the function is ran.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">example</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm">Evaluated as-</span>
<span class="cm">example(2+3, 7) -&gt; example(5, 7) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm">*/</span>
</pre></div>
<p><strong>Call by name (CBN)</strong> - All the arguments are passed to the function body as it is and evaluation is done by the code within the function body.</p>
<p>Example:</p>
<div class="highlight"><pre><span class="n">example</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Evaluated as-</span>
<span class="cm"> * example(2+3, 7) -&gt; (2+3) * (2+3) -&gt; 5 * (2+3) -&gt; 5 * 5 -&gt; 25</span>
<span class="cm"> */</span>
</pre></div>
<p>If CBV evaluation of an expression <em>e</em> terminates, then CBN evaluation of <em>e</em> terminates too.</p>
<p>The other direction is not true.</p>
<p>Non-termination example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>

<span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">loop</span><span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * Here, the loop resolves to itself infinitely.</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBN:</span>
<span class="cm"> * first(1, loop) -&gt; 1</span>
<span class="cm"> * </span>
<span class="cm"> * Under CBV:</span>
<span class="cm"> * first(1, loop) -&gt; first(1, loop) -&gt; first(1, loop)....</span>
<span class="cm"> */</span>
</pre></div>
<p>Scala normally uses call-by-value.</p>
<p>But if the type of a function parameter starts with =&gt;, it uses call-by-name.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">consOne</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="cm">/* Here, x is evaluated as CBV by default and y is evaluated as CBN which we explicitly forced it to. */</span>
</pre></div>
<p><strong>Conditional Expressions</strong></p>
<p>if-else in Scala is used for expressions, not statements.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span>
</pre></div>
<p>Rewrite rules for Booleans (e is an arbitrary expression):</p>
<div class="highlight"><pre><span class="cm">/* !true        --&gt; false</span>
<span class="cm"> * !false       --&gt; true</span>
<span class="cm"> * true &amp;&amp; e    --&gt; e</span>
<span class="cm"> * false &amp;&amp; e   --&gt; false</span>
<span class="cm"> * true || e    --&gt; true</span>
<span class="cm"> * false || e   --&gt; e</span>
<span class="cm"> */</span>
</pre></div>
<p><strong>Value Definitions</strong></p>
<p>The <code>def</code> form is &ldquo;by name&rdquo;, its right hand side evaluated on each use.</p>
<p>There is also a <code>val</code> for, which is &ldquo;by value&rdquo;. Example-</p>
<div class="highlight"><pre><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">square</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div>
<p>The right hand side of a val definition is evaluated at the point of the definition itself.</p>
<p>Afterwards the name refers to the value. Here y refers to 4, not square(2).</p>
<p><strong>Difference between val and def</strong></p>
<p>The difference becomes apparent when the right hand side does not terminate.</p>
<div class="highlight"><pre><span class="cm">/* This works fine. */</span>
<span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">loop</span>
<span class="k">def</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>

<span class="cm">/* However, this will get stuck in an infinite loop since the interpreter tries to evaluate the loop right at the point of definition. */</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">loop</span>
</pre></div>
<p>&amp;&amp; and || implementation as functions-</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">and</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">false</span>
<span class="k">def</span> <span class="n">or</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">x</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="kc">true</span>
</pre></div>
<p><strong>Return type is required when calling a function recursively.</strong></p>
<p><strong>Blocks in Scala</strong></p>
<p>A block is defined by curly braces {&hellip;.}.</p>
<div class="highlight"><pre><span class="o">{</span>
    <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
    <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div>
<p>It constains a sequence of definition or expressions.
The last element of a block is an expression that denes its value.
This return expression can be preceded by auxiliary denitions.
Blocks are themselves expressions; a block may appear everywhere an expression can.</p>

<ul>
<li>The denitions inside a block are only visible from within the block.</li>
<li>The denitions inside a block shadow denitions of the same names outside the block.</li>
</ul>
<p><strong>Semicolons</strong></p>
<p>In Scala, semicolons at the end of a line is optional in most cases. If there are more than one statements in one line, then they need to be separatd with a semi-colon.</p>
<p><strong>Semicolons and inx operators</strong></p>
<p>One issue with Scalas semicolon convention is how to write expressions that span several lines. For instance-</p>
<div class="highlight"><pre><span class="n">someLongExpression</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>

<span class="cm">/* would be interpreted as */</span>

<span class="n">someLongExpression</span><span class="o">;</span>
<span class="o">+</span> <span class="n">someOtherExpression</span>
</pre></div>
<p>Two ways to overcome the problem.</p>
<div class="highlight"><pre><span class="cm">/* Multiline expression can be written inside parentheses. */</span>
<span class="o">(</span><span class="n">someLongExpression</span>
    <span class="o">+</span> <span class="n">someOtherExpression</span><span class="o">)</span>

<span class="cm">/* Or operator can be written on the first line because this tells the Scala compiler that the expression is not yet finished. */</span>
<span class="n">someLongExpression</span> <span class="o">+</span>
<span class="n">someOtherExpression</span>
</pre></div>
<p><strong>Tail Recursion</strong></p>
<p>If a function calls itself as its last action, the function&#39;s stack frame can be reused. This is called tail recursion. Tail recursive functions are iterative processes.</p>
<p>In general, if the last action of a function consists of calling a function (which may be the same), one stack frame would be sucient for both functions. Such calls are called tail-calls.</p>
<p>Example of non-tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
<p>Example of tail recursive factorial function:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
    <span class="k">def</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">accum</span>
        <span class="k">else</span> <span class="n">fac_loop</span><span class="o">(</span><span class="n">accum</span> <span class="o">*</span> <span class="n">n</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">loop</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
<p>In the first example, the return value <code>x * factorial(x-1)</code> has a pending calculation of x multiplied by factorial of (x-1) which would have to wait until that factorial has been computed and thus that recursive chain keeps on growing.</p>
<p>However, in the second example, for the return value <code>fac_loop(accum * n, n - 1)</code> the function calls itself and there are no pending computation to be done, so the further function calls can take place in the same stack frame without growing like crazy like in the previous example.</p>
]]>
        </content>
    </entry>
</feed>